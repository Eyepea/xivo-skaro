#!/usr/bin/env python
# -*- coding: utf8 -*-
__author__  = "Nicolas HICHER <nhicher@proformatique.com>"
__license__ = """
    Copyright (C) 2011  Proformatique <technique@proformatique.com>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import socket
import sys
import subprocess
from configobj import ConfigObj
from optparse import OptionParser
from xivo_ha.manage_nodes import ClusterEngine
from xivo_ha.manage_nodes import ManageService
from xivo_ha.manage_nodes import FilesReplicationManagement
from xivo_ha.manage_cluster import ClusterResourceManager
from xivo_ha.manage_cluster import DatabaseManagement
from xivo_ha.tools import Tools

if __name__ == '__main__':

# from http://stackoverflow.com/questions/319279/how-to-validate-ip-address-in-python
    def _check_ipv4_address(address):
        '''check if ip address is valid'''
        try:
            addr= socket.inet_pton(socket.AF_INET, address)
        except AttributeError: 
            try:
                addr= socket.inet_aton(address)
            except socket.error:
                return False
            return address.count('.') == 3
        except socket.error: # not a valid address
            return False
        return True

    def _get_extra_services(_file):
        if not os.path.exists(_file):
            return

        for l in open(_file):
            data = l.replace(' ', '').strip()
            data = data.split("=")
            if data[0] == 'services' and data[1] is not '':
                services = data[1].split(',')
                return services

    #def _get_extra_scripts():
    #    for l in open(extra):
    #        data = l.replace(' ', '').strip()
    #        data = data.split("=")
    #        if data[0] == 'scripts' and data[1] is not '':
    #            scripts = data[1].split(',')
    #            cluster_config['scripts'] = scripts
    #            return True


    def _check_if_service_exist(service):
        file_ = "/etc/init.d/%s" % service
        if not os.path.isfile(file_):
            warn = "init file %s does not exist" % file_
            raise IOError(warn)


    def _check_if_itf_exist():
        '''
        check if interfaces specified in pf-xivo-ha.conf exist
        '''
        itfs =  cluster_config['cluster_addr']
        if not isinstance(itfs, (list,tuple)):
            itfs = [itfs]

        for itf in itfs:
            itf = itf.split(':')[0]
            args = ['ip', 'a', 's', itf]
            data = subprocess.Popen(args, stdout = subprocess.PIPE, stderr = subprocess.STDOUT)
            ret = data.wait()
            if ret is not 0:
                raise OSError("interface %s is not configured" % itf)
            

    def _get_extra_csync_data(_file):
        if not os.path.exists(_file):
            return

        for l in open(_file):
            data = l.replace(' ', '').strip()
            data = data.split("=")
            if data[0] == 'extra_include' and data[1] is not '':
                data = data[1].split(',')
                csync_data['extra_include'] = data
            if data[0] == 'extra_exclude' and data[1] is not '':
                data = data[1].split(',')
                csync_data['extra_exclude'] = data


    parser = OptionParser()
    parser.add_option('--node', dest='node', type='string', metavar='ACTION',
            help='configure node, must be used executed on each node (init or update)\n'
                 'you must specify --role and --hostname')
    parser.add_option('--cluster', dest='cluster', type='string', metavar='ACTION',
            help='configure the cluster resource manager (manage or status)')
    parser.add_option('-m', '--master', dest='master', action='store_true',
            help='specify if the node is master')
    parser.add_option('-s', '--slave', dest='slave', action='store_true',
            help='specify if the node is slave')
    parser.add_option('-f', '--config_file', dest='config_file', type='string', metavar='CONFIG_FILE',
            help='specify the config file to use (default : /etc/pf-xivo/xivo_ha/pf-xivo-ha.conf)')
    parser.add_option('--dry-run', dest='dry_run', action="store_true",
            help='print cluster data')
    (options, args) = parser.parse_args()


    if options.config_file is None:
        config_file = '/etc/pf-xivo/xivo_ha/pf-xivo-ha.conf'
    else:
        config_file = options.config_file

    config = ConfigObj(config_file)

    # check if one option is given
    if options.node is None and options.cluster is None and options.dry_run is None:
        parser.error("You have to provide an option")

    if options.node:
        if options.master is None and options.slave is None:
            parser.error('you have to specify role for this node (--master or --slave)')

    extra_file = "/etc/pf-xivo/xivo_ha/pf-xivo-ha-extra.conf"

    role = 'master' if options.master else 'slave'

    # corosync data
    nodes_config   = config['nodes']
    network_addr   = nodes_config['network_addr']
    multicast_addr = nodes_config['multicast_addr']
    services       = config['cluster']['services'].keys()
    # TODO : force master or slave 
    nodes_config['master'] = options.master

    nodes = [
             nodes_config['first_node']['name'],
             nodes_config['second_node']['name']
            ]
    # cluster data
    cluster_config = config['cluster']
    cluster_config['cluster_nodes'] = nodes 

    extra_services = _get_extra_services(extra_file) 
    #extra_scripts  = _get_extra_scripts()

    if extra_services is not None:
        # node data
        services = services + extra_services
        # cluster data
        for service in extra_services:
            _check_if_service_exist(service)
            cluster_config['services'][service] = {}

    for service, data in cluster_config['services'].iteritems():
        if type(data) is str:
            cluster_config['services'][service] = {}
            key, value = data.split(':')
            cluster_config['services'][service][key] = value
        else:
            cluster_config['services'][service] = {}
            for elem in data:
                key, value = elem.split(':')
                cluster_config['services'][service][key] = value

    node_management  = ClusterEngine(network_addr, multicast_addr)
    cluster          = ClusterResourceManager(cluster_config)
    db               = DatabaseManagement(options.master, config)

    # csync2 configuration.
    csync_data = {}
    csync_data['hosts']    = nodes
    csync_data['data_itf'] = cluster_config['cluster_itf_data']
    csync_data['role']     = role
    _get_extra_csync_data(extra_file)
    csync2 = FilesReplicationManagement(csync_data)

    if cluster_config.has_key('cluster_addr'):
        _check_if_itf_exist()

    for address in network_addr, multicast_addr:
        _check_ipv4_address(address)

    if options.dry_run:
        print('---- Nodes configuration ----')
        print(nodes_config)
        print('-----------------------------')
        print('---- Csync configuration ----')
        print(csync_data)
        print('-----------------------------')
        print('---- Cluster configuration ----')
        print(cluster_config)
        print('-----------------------------')
        sys.exit()

    if options.node:
        if options.node == 'init':
            print('node initialization')
            db.initialize()
            node_management.initialize()
            for service in services:
                manage_service = ManageService(service)
                manage_service.initialize()
            csync2.initialize()
            #if role == 'master':
            #    print('starting nginx on master')
        elif options.node == 'update':
            raise NotImplementedError
        else:
            parser.error("this option is not allowed")

    if options.cluster:
        option = options.cluster
        if option == 'manage':
            cluster.manage() 
        elif option == 'status':
            cluster.status()
        elif option == 'stop_res':
            cluster.cluster_stop_res()
        elif option == 'start_res':
            cluster.cluster_start_res()
        elif option == 'config_file':
            cluster.create_config_file()
        else:
            parser.error("this option is not allowed")
