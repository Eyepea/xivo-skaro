#!/usr/bin/python
# -*- coding: UTF-8 -*-

__version__ = "$Revision$ $Date$"
__license__ = """
    Copyright (C) 2010-2011  Proformatique <technique@proformatique.com>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import itertools
import logging
import optparse
import os
import sys
import traceback
from operator import itemgetter
from fetchfw import cli, config, util


def install(pkg_manager, opt, args):
    if not args:
        print >>sys.stderr, "error: no targets specified"
        sys.exit(1)
    installer = cli.CliInstaller()
    pkg_manager.install(args, installer)


def upgrade(pkg_manager, opt, args):
    if args:
        print >>sys.stderr, "error: upgrade doesn't accept arguments"
        sys.exit(1)
    if opt.ignore:
        upgrader = cli.CliUpgrader(ignore=opt.ignore)
    else:
        upgrader = cli.CliUpgrader()
    pkg_manager.upgrade(upgrader)


def search_installable(pkg_manager, opt, args):
    if len(args) > 1:
        print >>sys.stderr, "warning: ignoring search words after the first space"
    if not args:
        word = ''
    else:
        word = args[0].lower()
    for installable_pkg in sorted_itervalues(pkg_manager.installable_pkgs):
        if word in installable_pkg.name.lower():
            if installable_pkg.name in pkg_manager.installed_pkgs:
                installed_pkg = pkg_manager.installed_pkgs[installable_pkg.name]
                if installed_pkg.version != installable_pkg.version:
                    print installable_pkg, "[installed: %s]" % installed_pkg.version
                else:
                    print installable_pkg, "[installed]"
            else:
                print installable_pkg
            print '   ', installable_pkg.description


def info_installable(pkg_manager, opt, args):
    if not args:
        print >>sys.stderr, "error: no targets specified"
        sys.exit(1)
    for pkg_name in args:
        if pkg_name not in pkg_manager.installable_pkgs:
            print >>sys.stderr, "error: package '%s' was not found" % pkg_name
        else:
            pkg = pkg_manager.installable_pkgs[pkg_name]
            print 'Name\t\t:', pkg.name
            print 'Version\t\t:', pkg.version
            if pkg.dependencies:
                depends_on = ' '.join(pkg.dependencies)
            else:
                depends_on = 'None'
            print 'Depends On\t:', depends_on
            print 'Description\t:', pkg.description
            print


def list_installed(pkg_manager, opt, args):
    if args:
        for pkg_name in args:
            if pkg_name in pkg_manager.installed_pkgs:
                installed_pkg = pkg_manager.installed_pkgs[pkg_name]
                print installed_pkg
            else:
                print >>sys.stderr, "error: package '%s' not found" % pkg_name
    else:
        for installed_pkg in sorted_itervalues(pkg_manager.installed_pkgs):
            print installed_pkg


def info_installed(pkg_manager, opt, args):
    if not args:
        print >>sys.stderr, "error: no targets specified"
        sys.exit(1)
    for pkg_name in args:
        if pkg_name not in pkg_manager.installed_pkgs:
            print >>sys.stderr, "error: package '%s' not found" % pkg_name
        else:
            pkg = pkg_manager.installed_pkgs[pkg_name]
            print 'Name\t\t:', pkg.name
            print 'Version\t\t:', pkg.version
            if pkg.dependencies:
                depends_on = ' '.join(pkg.dependencies)
            else:
                depends_on = 'None'
            print 'Depends On\t:', depends_on
            print 'Required By\t:', "TODO"
            print 'Install Reason\t:', 'Explicitly installed' if pkg.explicitly_installed else 'Installed as a dependency for another package'
            print 'Description\t:', pkg.description
            print


def search_installed(pkg_manager, opt, args):
    if len(args) > 1:
        print >>sys.stderr, "warning: ignoring search words after the first space"
    if not args:
        word = ''
    else:
        word = args[0].lower()
    for installed_pkg in sorted_itervalues(pkg_manager.installed_pkgs):
        if word in installed_pkg.name.lower():
            print installed_pkg
            print '   ', installed_pkg.description


def list_files_installed(pkg_manager, opt, args):
    if not args:
        print >>sys.stderr, "error: no targets specified"
        sys.exit(1)
    for pkg_name in args:
        if pkg_name not in pkg_manager.installed_pkgs:
            print >>sys.stderr, "error: package '%s' not found" % pkg_name
        else:
            installed_pkg = pkg_manager.installed_pkgs[pkg_name]
            if not installed_pkg.installed_files:
                print pkg_name, "-- no installed files"
            else:
                for file in installed_pkg.installed_files:
                    print pkg_name, file


def remove(pkg_manager, opt, args):
    if not args:
        print >>sys.stderr, "error: no targets specified"
        sys.exit(1)
    uninstaller = cli.CliUninstaller(recursive=opt.recursive)
    pkg_manager.uninstall(args, uninstaller)


def check_is_root():
    if os.geteuid() != 0:
        print >>sys.stderr, "error: you cannot perform this operation unless you are root"
        sys.exit(1)


def sorted_itervalues(dict_):
    return map(itemgetter(1), sorted(dict_.iteritems(), key=itemgetter(0)))


def sorted_iterkeys(dict_):
    return sorted(dict_)


def sorted_iteritems(dict_):
    return sorted(dict_.iteritems(), key=itemgetter(0))


# command parsing functions to help in displaying nice help. I though it
# was simpler than beginning to override optparse there and there to make
# it fit the usage

def discard_positional_params(argv):
    # Return a copy of argv where every parameters after a '--' is discarded
    return list(itertools.takewhile(lambda s: s != '--', argv))


def _is_short_option(s):
    return s.startswith('-') and not s.startswith('--')


def _get_short_options(argv):
    # Return a set of short options in argv
    short_options_groups = filter(_is_short_option, argv)
    return set(c for group in short_options_groups for c in group[1:])


def _is_long_options(s):
    return s.startswith('--')


def _get_long_options(argv):
    return set(map(itemgetter(slice(2, None)), filter(_is_long_options, argv)))


def get_options(argv):
    # Return a tuple (short options, long options)
    cleaned_argv = discard_positional_params(argv)
    return _get_short_options(cleaned_argv), _get_long_options(cleaned_argv)


def has_option((short_opt, long_opt), (short_opts, long_opts)):
    if short_opt and short_opt in short_opts:
        return True
    else:
        return long_opt and long_opt in long_opts


def get_option_subset(options_set, options):
    return set(opt for opt in options_set if has_option(opt, options))


def do_operation_sync(pkg_manager, opt, args):
    sub_op = tuple(bool(x) for x in [opt.info, opt.search, opt.upgrade])
    if (False, False, False) == sub_op:
        check_is_root()
        install(pkg_manager, opt, args)
    elif (True, False, False) == sub_op:
        info_installable(pkg_manager, opt, args)
    elif (False, True, False) == sub_op:
        search_installable(pkg_manager, opt, args)
    elif (False, False, True) == sub_op:
        check_is_root()
        upgrade(pkg_manager, opt, args)
    else:
        print >>sys.stderr, 'error: invalid sync operation'
        sys.exit(1)


def do_operation_query(pkg_manager, opt, args):
    sub_op = tuple(bool(x) for x in [opt.info, opt.list, opt.search])
    if (False, False, False) == sub_op:
        list_installed(pkg_manager, opt, args)
    elif (True, False, False) == sub_op:
        info_installed(pkg_manager, opt, args)
    elif (False, True, False) == sub_op:
        list_files_installed(pkg_manager, opt, args)
    elif (False, False, True) == sub_op:
        search_installed(pkg_manager, opt, args)
    else:
        print >>sys.stderr, 'error: invalid query operation'
        sys.exit(1)


def do_operation_remove(pkg_manager, opt, args):
    check_is_root()
    remove(pkg_manager, opt, args)


class CustomHelpFormatter(optparse.IndentedHelpFormatter):
    def format_epilog(self, epilog):
        return "\n" + epilog + "\n"


def new_common_option_parser(*args, **kwargs):
    kwargs.setdefault('formatter', CustomHelpFormatter)
    kwargs['formatter'] = CustomHelpFormatter()
    p = optparse.OptionParser(*args, **kwargs)
    p.add_option('--config', action='store',
                 help='set an alternate configuration file')
    p.add_option('--debug', action='store_true',
                 help='display debug messages')
    return p



SYNC_USAGE='Usage:  xivo_fetchfw {-S --sync} [options] [package(s)]'
SYNC_EPILOG="""\
Example:
    xivo_fetchfw -S digium-tc400
        Install digium-tc400m package.
    xivo_fetchfw -Ss digium
        Return all installable package with the word digium in it
    xivo_fetchfw -Si digium-tc400
        Show info about the digium-tc400 package.
    xivo_fetchfw -Su
        Upgrade all installed package.\
"""

def new_sync_option_parser():
    p = new_common_option_parser(usage=SYNC_USAGE, add_help_option=False,
                                 epilog=SYNC_EPILOG)
    p.add_option('-S', '--sync', action='store_true',
                 help=optparse.SUPPRESS_HELP)
    p.add_option('-i', '--info', action='store_true',
                 help='view package information')
    p.add_option('-s', '--search', action='store_true',
                 help='search packages for matching strings')
    p.add_option('-u', '--upgrade', action='store_true',
                 help='upgrade installed packages')
    p.add_option('--ignore', action='store_true',
                 help='ignore a package upgrade')
    return p


QUERY_USAGE='Usage:  xivo_fetchfw {-Q --query} [options] [package(s)]'
QUERY_EPILOG="""\
Example:
    xivo_fetchfw -Q digium-tc400
        Show digium-tc400 package.
    xivo_fetchfw -Qs digium
        Return all installed package with the word digium in it
    xivo_fetchfw -Qi digium-tc400
        Show info about the digium-tc400 package.
    xivo_fetchfw -Ql digium-tc400
        List the content of the digium-tc400 package.\
"""

def new_query_option_parser():
    p = new_common_option_parser(usage=QUERY_USAGE, add_help_option=False,
                                 epilog=QUERY_EPILOG)
    p.add_option('-Q', '--query', action='store_true',
                 help=optparse.SUPPRESS_HELP)
    p.add_option('-i', '--info', action='store_true',
                 help='view package information')
    p.add_option('-s', '--search', action='store_true',
                 help='search packages for matching strings')
    p.add_option('-l', '--list', action='store_true',
                 help='list the package contents')
    return p


REMOVE_USAGE='Usage:  xivo_fetchfw {-R --remove} [options] <package(s)>'
REMOVE_EPILOG="""\
Example:
    xivo_fetchfw -R digium-tc400
        Remove the digium-tc400 package.
    xivo_fetchfw -Rs digium-tc400
        Remove the digium-tc400 and all it's unused dependencies.\
"""

def new_remove_option_parser():
    p = new_common_option_parser(usage=REMOVE_USAGE, add_help_option=False,
                                 epilog=REMOVE_EPILOG)
    p.add_option('-R', '--remove', action='store_true',
                 help=optparse.SUPPRESS_HELP)
    p.add_option('-s', '--recursive', action='store_true',
                 help='remove unnecessary dependencies')
    return p


OPERATIONS = {
    # (<short_opt>, <long_opt>): (option parser factory, do_operatiion_fun>)
    ('S', 'sync'): (new_sync_option_parser, do_operation_sync),
    ('Q', 'query'): (new_query_option_parser, do_operation_query),
    ('R', 'remove'): (new_remove_option_parser, do_operation_remove),
}


def new_option_parser_from_option(opt):
    return OPERATIONS[opt][0]()


def do_fun_from_option(opt):
    return OPERATIONS[opt][1]


def init_logging():
    logger = logging.getLogger()
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter("%(asctime)s: %(message)s"))
    logger.addHandler(handler)
    logger.setLevel(logging.WARNING)


GENERIC_HELP_MSG = """\
Usage:  xivo_fetchfw <operation> [...]

Operations:
    xivo_fetchfw {-h --help}
    xivo_fetchfw {-Q --query}  [options] [package(s)]
    xivo_fetchfw {-R --remove} [options] <package(s)>
    xivo_fetchfw {-S --sync}   [options] [package(s)]

use 'xivo_fetchfw {-h --help}' with an operation for available options

Examples:
    xivo_fetchfw -S digium-tc400m
        Install digium-tc400m package.
    xivo_fetchfw -Ss digium
        Return all installable package with the words digium in it
    xivo_fetchfw -Qs digium
        Return all installed digium package
    xivo_fetchfw -R digium-tc400m
        Uninstall the digium-tc400m package\
"""

def parse_options():
    options = get_options(sys.argv[1:])
    cur_operations = get_option_subset(OPERATIONS, options)
    if has_option(('h', 'help'), options):
        if not cur_operations:
            print >>sys.stderr, GENERIC_HELP_MSG
        elif len(cur_operations) == 1:
            p = new_option_parser_from_option(cur_operations.pop())
            p.print_help(sys.stderr)
        else:
            print >>sys.stderr, "error: only one operation may be used at a time"
        sys.exit(1)
    else:
        if not cur_operations:
            print >>sys.stderr, "error: no operation specified (use -h for help)"
            sys.exit(1)
        elif len(cur_operations) == 1:
            operation = cur_operations.pop()
            p = new_option_parser_from_option(operation)
            opt, args = p.parse_args()
            do_fun = do_fun_from_option(operation)
            return opt, args, do_fun
        else:
            print >>sys.stderr, "error: only one operation may be used at a time"
            sys.exit(1)


if __name__ == '__main__':
    init_logging()
    
    try:
        opt, args, operation_fun = parse_options()
        
        if opt.debug:
            logger = logging.getLogger()
            logger.setLevel(logging.DEBUG)
        
        cfg_filename = opt.config or config.DEF_CFG_FILENAME
        pkg_manager = config.new_package_manager(cfg_filename)
        
        operation_fun(pkg_manager, opt, args)
        
    except cli.UserCancellationError:
        pass
    except config.ConfigError, e:
        print >>sys.stderr, "error: config file '%s': %s" % (cfg_filename, e)
        if opt.debug:
            traceback.print_exc()
        sys.exit(1)
    except util.FetchfwError, e:
        print >>sys.stderr, "error:", e
        if opt.debug:
            traceback.print_exc()
        sys.exit(1)
    except Exception:
        print >>sys.stderr, "Unexpected exception:"
        traceback.print_exc()
        sys.exit(1)
