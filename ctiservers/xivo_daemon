#!/usr/bin/python
# vim: set fileencoding=utf-8 :

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Alternatively, XiVO CTI Server is available under other licenses directly
# contracted with Pro-formatique SARL. See the LICENSE file at top of the
# source tree or delivered in the installable package in which XiVO CTI Server
# is distributed for more details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


__version__   = '$Revision$'
__date__      = '$Date$'
__copyright__ = 'Copyright (C) 2007-2011 Proformatique'
__author__    = 'Corentin Le Gall'

"""
# 1) General description of XiVO CTI Server
# The XiVO CTI Server is a general-purpose daemon, whose basic features are :
#  - the monitoring of one or more Asterisk, through AMI
#  - taking care of Asteriks AGI requests
#  - the ability to receive incoming "CTI clients" connections
#  - the ability to relay commands (between a Web interface and Asterisk)
#  - the connection to one or more databases (cdr, directory, ...)
#  - the connection to a given server
# 
# 2) Primary data structures
# 
#  - users list
#  - contexts/companies list
# 
#  - asterisk / configurations
#  - phonelist
#
# 3) Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks)
# - the incoming TCP sockets (CTI, WEBI, INFO, FAGI)
#
# 4) Custom-defined Plugins
#
"""

# debian.org modules
import datetime
import getopt
import os
import select
import signal
import ssl
import socket
import string
import sys
import threading
import time
import logging
from logging.handlers import RotatingFileHandler
import Queue
import urllib
import cjson

# XIVO lib-python modules initialization
from xivo import daemonize

# XIVO CTI modules
from xivo_ctiservers.client_connection import ClientConnection
from xivo_ctiservers import cti_config
from xivo_ctiservers import interface_webi
from xivo_ctiservers import interface_info
from xivo_ctiservers import interface_cti
from xivo_ctiservers import interface_ami
from xivo_ctiservers import interface_fagi
from xivo_ctiservers import interface_rcti
from xivo_ctiservers import innerdata
from xivo_ctiservers import amiinterpret
from xivo_ctiservers import queue_logger
from xivo_ctiservers.alarm import scheduler
from xivo_ctiservers.alarm import alarm

__alphanums__ = string.uppercase + string.lowercase + string.digits

LOGDAEMONNAME = 'ctid'
try:
    DAEMONNAME = os.path.basename(sys.argv[0])
except:
    DAEMONNAME = 'ctid'

XIVO_CONF_FILE_DEFAULT = 'file:///etc/pf-xivo/ctiservers/ctiserver_default_configuration.json'

DEBUG_MODE         = False
XIVO_CONF_FILE     = 'https://localhost/cti/json.php/private/configuration'
XIVO_CONF_OVER     = None
PIDFILE            = '/var/run/%s.pid' % DAEMONNAME
LOGFILENAME        = '/var/log/pf-xivo-cti-server/daemon.log'
XIVOIP             = 'localhost'
ALARM_DIRECTORY    = '/var/lib/pf-xivo-cti-server/alarms'
PORTDELTA          = 0
GETOPT_SHORTOPTS   = 'dc:C:p:l:i:P:'
GETOPT_LONGOPTS    = ['debug', 'config=', 'confoverride=', 'pidfile=',
                      'logfile=', 'ip=', 'portdelta=']

BUFSIZE_LARGE = 262144

SSLPROTO = ssl.PROTOCOL_TLSv1

def parse_command_line():
    global DEBUG_MODE, XIVO_CONF_FILE, XIVO_CONF_OVER, PIDFILE, LOGFILENAME, XIVOIP, PORTDELTA
    for opt, arg in getopt.getopt( sys.argv[1:], GETOPT_SHORTOPTS, GETOPT_LONGOPTS)[0]:
        if opt == '-d':
            DEBUG_MODE = True
        elif opt == '-c':
            XIVO_CONF_FILE = arg
        elif opt == '-C':
            XIVO_CONF_OVER = arg
        elif opt == '-p':
            PIDFILE = arg
        elif opt == '-l':
            LOGFILENAME = arg
        elif opt == '-i':
            XIVOIP = arg
        elif opt == '-P':
            PORTDELTA = int(arg)


class ctiserver:
    xivoversion = '1.2'
    revision = 'githash'
    xdname = 'XiVO CTI Server'

    def __init__(self):
        # print sys.getdefaultencoding()
        logging.basicConfig(level = logging.INFO)
        #logging.basicConfig(level = logging.DEBUG)

        global log

        log = logging.getLogger('main')

        try:
            logfilehandler = RotatingFileHandler(LOGFILENAME)
            formatter = logging.Formatter('%%(asctime)s %s[%%(process)d] (%%(levelname)s) (%%(name)s): %%(message)s'
                                          % LOGDAEMONNAME)
            logfilehandler.setFormatter(formatter)
            root_logger = logging.getLogger()
            root_logger.addHandler(logfilehandler)
            if DEBUG_MODE:
                root_logger.setLevel(logging.DEBUG)

        except Exception:
            log.exception('logfilehandler')

        if not DEBUG_MODE:
            daemonize.daemonize()

        daemonize.lock_pidfile_or_die(PIDFILE)

        self.nreload = 0
        self.myami = {}
        self.mycti = {}
        self.safe = {}
        self.timeout_queue = Queue.Queue()
        self.pipe_queued_threads = None
        self.scheduler = scheduler.Scheduler()
        persister = alarm.JSONPersister(ALARM_DIRECTORY)
        persister = alarm.MaxDeltaPersisterDecorator(datetime.timedelta(hours=2),
                                                     persister)
        try:
            system_zone = alarm.get_system_zone()
        except Exception, e:
            log.warning('Error while getting system zone: %s', e)
            system_zone = None
        self.alarm_mgr = alarm.AlarmClockManager(self.scheduler, persister,
                                                 self._alarm_callback,
                                                 system_zone)
        self.global_zone = None

        signal.signal(signal.SIGINT, self.sighandler)
        signal.signal(signal.SIGTERM, self.sighandler)
        signal.signal(signal.SIGHUP, self.sighandler_reload)

        while True:
            try:
                self.main_loop()
            except Exception:
                log.exception('main loop has crashed ... retrying in 5 seconds ...')
                time.sleep(5)
    
    def _alarm_callback(self, data):
        # WARNING: we are in the scheduler thread
        userid = data['userid']
        os.write(self.pipe_queued_threads[1], 'alarmclk:%s\n' % userid)
    
    ## \brief Handler for catching signals (in the main thread)
    # \param signum signal number
    # \param frame frame
    # \return none
    def sighandler(self, signum, frame):
        log.warning('(sighandler) signal %s lineno %s (atq = %s) received : quits'
                    % (signum, frame.f_lineno, self.askedtoquit))
        self.scheduler.shutdown()
        for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
            print '--- living thread <%s>' % (t.getName())
            t._Thread__stop()
        self.askedtoquit = True
        return

    ## \brief Handler for catching signals (in the main thread)
    # \param signum signal number
    # \param frame frame
    # \return none
    def sighandler_reload(self, signum, frame):
        log.warning('(sighandler_reload) signal %s lineno %s (atq = %s) received : reloads'
                    % (signum, frame.f_lineno, self.askedtoquit))
        self.askedtoquit = False
        return

    def manage_tcp_connections(self, sel_i, msg, kind):
        """
        Dispatches the message's handling according to the connection's kind.
        """
        closemenow = False
        if not isinstance(kind, str): # CTI, INFO, WEBI
            replies = kind.manage_connection(msg)
            for reply in replies:
                if reply:
                    if reply.has_key('closemenow'):
                        closemenow = reply.get('closemenow')
                    if reply.has_key('message'):
                        if reply.get('dest'):
                            self.send_to_cti_client(reply.get('dest'),
                                                    reply.get('message'))
                        else:
                            kind.reply(reply.get('message'))
                    elif reply.has_key('warning'):
                        kind.reply(reply.get('warning'))
            # issue : when to define the recipient list ?
            # change status
            # find changes
            # warn
        else:
            log.warning('unknown connection kind %s' % kind)
        return closemenow

    def find_matching_ipbxid(self, ipaddress):
        found_ipbxid = None
        for ipbxid, ipbxconfig in self.cconf.getconfig('ipbxes').iteritems():
            if 'ipbx_connection' in ipbxconfig:
                connparams = ipbxconfig.get('ipbx_connection')
                cfg_ip_address = connparams.get('ipaddress')
                if ipaddress == socket.gethostbyname(cfg_ip_address):
                    found_ipbxid = ipbxid
                    break
        return found_ipbxid

    def checkqueue(self):
        log.info('entering checkqueue')
        ncount = 0
        while self.timeout_queue.qsize() > 0:
            ncount += 1
            (toload,) = self.timeout_queue.get()
            action = toload.get('action')
            if action == 'ipbxup':
                sockparams = toload.get('properties').get('sockparams')
                data = toload.get('properties').get('data')
                if data.startswith('asterisk'):
                    got_ip_address = sockparams[0]
                    ipbxid = self.find_matching_ipbxid(got_ip_address)
                    if ipbxid:
                        if self.myami[ipbxid].connected():
                            log.info('do NOT attempt to reconnect to the AMI for %s' % ipbxid)
                        else:
                            log.info('attempt to reconnect to the AMI for %s' % ipbxid)
                            z = self.myami[ipbxid].connect()
                            if z:
                                self.fdlist_ami[z] = self.myami[ipbxid]
                    else:
                        log.warning('did not found a matching ipbxid for the address %s'
                                    % got_ip_address)
            elif action == 'xivoremote':
                for k, v in self.mycti.iteritems():
                    if not v.connected():
                        z = v.connect()
                        if z:
                            self.fdlist_remote_cti[z] = v
            elif action == 'ctilogin':
                connc = toload.get('properties')
                connc.close()
                if connc in self.fdlist_established:
                    del self.fdlist_established[connc]
                else:
                    log.warning('could not remove connexion : already done ...')
            else:
                log.warning('checkqueue : unknown action received : %s' % action)
        return ncount

    def cb_timer(self, *args):
        try:
            tname = threading.currentThread()
            tname.setName('Thread-main')
            log.info('cb_timer (timer finished at %s) %s' % (time.asctime(), args))
            self.timeout_queue.put(args)
            os.write(self.pipe_queued_threads[1], 'main:\n')
        except Exception:
            log.exception('cb_timer %s' % args)
        return

    def updates_period(self):
        return int(self.cconf.getconfig('main').get('updates_period', '3600'))

    def main_loop(self):    # {
        self.askedtoquit = False

        self.time_start = time.localtime()
        log.info('# STARTING XiVO CTI Server %s (pid %d) / git:%s # (0/3) Starting (%d)'
                 % (self.xivoversion, os.getpid(), self.revision, self.nreload))
        self.nreload += 1

        # global default definitions
        self.update_userlist = {}
        self.lastrequest_time = {}

        self.cconf = cti_config.Config(XIVO_CONF_FILE, XIVO_CONF_FILE_DEFAULT)
        self.cconf.set_ipwebs(XIVOIP)
        if XIVO_CONF_OVER:
            urldata = urllib.urlopen(XIVO_CONF_OVER)
            payload = urldata.read()
            urldata.close()
            overconf = cjson.decode(payload)
            self.cconf.set_rcti_override_ipbxes(overconf)
        self.cconf.update()
        self.cconf.set_rcti_special_profile()

        queue_logger.queue_logger.init(self.cconf.getconfig('main').get('asterisk_queuestat_db'))

        xivoconf_general = self.cconf.getconfig('main')

        # loads the general configuration
        ctilog = xivoconf_general.get('ctilog_db_uri')
        socktimeout = float(xivoconf_general.get('sockettimeout', '2'))
        prefixfile = xivoconf_general.get('prefixfile')
        parting_ipbxid_context = xivoconf_general.get('parting_ipbxid_context')

        socket.setdefaulttimeout(socktimeout)

        if not self.pipe_queued_threads:
            self.pipe_queued_threads = os.pipe()

        # sockets management
        self.fdlist_established = {}
        self.fdlist_listen_cti = {}
        self.fdlist_udp_cti = {}
        self.fdlist_ami = {}
        self.fdlist_remote_cti = {}

        log.info("the monitored ipbx's is/are : %s" % self.cconf.getconfig('ipbxes').keys())

        for ipbxid, ipbxconfig in self.cconf.getconfig('ipbxes').iteritems():
            if 'ipbx_connection' in ipbxconfig:
                self.myipbxid = ipbxid
                break

        log.info('# STARTING %s # (1/3) Local AMI socket connection' % self.xdname)
        if self.myipbxid:
            ipbxconfig = self.cconf.getconfig('ipbxes').get(self.myipbxid)
            # interface : safe deposit
            self.safe[self.myipbxid] = innerdata.Safe(self, self.myipbxid,
                                                      ipbxconfig.get('urllists'))
            self.safe[self.myipbxid].update_directories()
            # interface : AMI
            self.myami[self.myipbxid] = interface_ami.AMI(self, self.myipbxid,
                                                          ipbxconfig.get('ipbx_connection'))
            self.commandclass = amiinterpret.AMI_1_8(self, self.myipbxid)

            log.info('# STARTING %s / git:%s / %d'
                     % (self.xdname, self.safe[self.myipbxid].version(), self.nreload))

            self.safe[self.myipbxid].set_ctilog(ctilog)
            self.safe[self.myipbxid].read_internatprefixes(prefixfile)
            self.safe[self.myipbxid].set_partings(parting_ipbxid_context)

            self.update_userlist[self.myipbxid] = []
            self.lastrequest_time[self.myipbxid] = time.time()

            z = self.myami[self.myipbxid].connect()
            if z:
                self.fdlist_ami[z] = self.myami[self.myipbxid]

            try:
                self.safe[self.myipbxid].update_config_list_all()
            except Exception:
                log.exception('%s : commandclass.updates()' % self.myipbxid)

        log.info('# STARTING %s # (2/3) Remote CTI connections' % self.xdname)
        for ipbxid, ipbxconfig in self.cconf.getconfig('ipbxes').iteritems():
            if ipbxid != self.myipbxid:
                log.info('other ipbx to connect to : %s' % ipbxid)
                try:
                    self.safe[ipbxid] = innerdata.Safe(self, ipbxid)
                    self.mycti[ipbxid] = interface_rcti.RCTI(self, ipbxid,
                                                             ipbxconfig.get('cti_connection'))
                except:
                    log.exception('remote CTI connection to %s' % ipbxid)

                self.update_userlist[ipbxid] = []
                self.lastrequest_time[ipbxid] = time.time()

                z = self.mycti[ipbxid].connect()
                if z:
                    self.fdlist_remote_cti[z] = self.mycti[ipbxid]
        # }

        log.info('# STARTING %s # (3/3) listening sockets (CTI, WEBI, FAGI, INFO)' % self.xdname)
        # opens the listening socket for incoming (CTI, WEBI, FAGI, INFO) connections
        for kind, bind_and_port in xivoconf_general.get('incoming_tcp', {}).iteritems():
            try:
                (bind, port) = bind_and_port
                trueport = int(port) + PORTDELTA
                gai = socket.getaddrinfo(bind, trueport, 0, socket.SOCK_STREAM, socket.SOL_TCP)
                if not gai:
                    continue
                (afinet, socktype, proto, dummy, bindtuple) = gai[0]
                UIsock = socket.socket(afinet, socktype)
                UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                UIsock.bind(bindtuple)
                UIsock.listen(10)
                self.fdlist_listen_cti[UIsock] = '%s:%s' % (kind, 1)
            except Exception:
                log.exception('tcp %s %d' % (bind, trueport))

        for kind, bind_and_port in xivoconf_general.get('incoming_udp', {}).iteritems():
            try:
                (bind, port) = bind_and_port
                trueport = int(port) + PORTDELTA
                gai = socket.getaddrinfo(bind, trueport, 0, socket.SOCK_DGRAM, socket.SOL_UDP)
                if not gai:
                    continue
                (afinet, socktype, proto, dummy, bindtuple) = gai[0]
                UIsock = socket.socket(afinet, socktype)
                UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                UIsock.bind(bindtuple)
                self.fdlist_udp_cti[UIsock] = '%s:%s' % (kind, 1)
            except Exception:
                log.exception('udp %s %d' % (bind, trueport))

        # Main select() loop - Receive messages
        if not self.cconf.getconfig():
            nsecs = 5
            log.info('waiting %d seconds in case a config would be available ...' % nsecs)
            try:
                time.sleep(nsecs)
                # select.select([], [], [], nsecs)
            except:
                sys.exit()
        else:
            # we call _schedule_alarms before starting the scheduler so that
            # alarms that have changed will be rescheduled before having a
            # chance to be fired
            self._schedule_alarms()
            self.scheduler.start()
            try:
                while not self.askedtoquit:
                    self.select_step()
            finally:
                self.scheduler.shutdown()
    # }

    def loop_over_cti_queue(self, innerdata):
        cti_queue = innerdata.events_cti
        queuesize = cti_queue.qsize()
        while cti_queue.qsize() > 0:
            it = cti_queue.get()
            for k in self.fdlist_established.itervalues():
                if not isinstance(k, str) and k.kind in ['CTI', 'CTIS']:
                    k.reply(it)
        return queuesize

    def get_connected(self, tomatch):
        clist = list()
        for k in self.fdlist_established.itervalues():
            if not isinstance(k, str) and k.kind in ['CTI', 'CTIS']:
                ipbxid = k.connection_details.get('ipbxid')
                userid = k.connection_details.get('userid')
                if self.safe.get(ipbxid).user_match(userid, tomatch):
                    clist.append(k)
        return clist

    def sendsheettolist(self, tsl, payload):
        for k in tsl:
            k.reply(payload)
        return

    def loop_over_cti_queues(self):
        for ipbxid, innerdata in self.safe.iteritems():
            queuesize = self.loop_over_cti_queue(innerdata)
##            if queuesize > 0:
##                log.info('loop_over_cti_queue %s %d items' % (ipbxid, queuesize))
        return

    def set_transfer_socket(self, faxobj, direction):
        for iconn, kind in self.fdlist_established.iteritems():
            if kind.kind in ['CTI', 'CTIS']:
                peername = '%s:%d' % iconn.getpeername()
                if peername == faxobj.socketref:
                    kind.set_as_transfer(direction, faxobj)
                    if direction == 's2c':
                        sendbuffer = ''
                        kind.reply(sendbuffer)
                    break
        return

    def send_to_cti_client(self, who, what):
        (ipbxid, userid) = who.split('/')
        for k in self.fdlist_established.itervalues():
            if not isinstance(k, str) and k.kind in ['CTI', 'CTIS']:
                if ipbxid == self.myipbxid:
                    if k.connection_details.get('userid') == userid:
                        k.reply(what)
                else:
                    if k.connection_details.get('userid')[3:] == ipbxid:
                        k.reply(what)

    def _schedule_alarms(self):
        # Schedule new alarms/reschedule updated alarm
        global_zone = self.cconf.getconfig('ipbxes').get(self.myipbxid, {}).get('timezone')
        userlist = self.safe[self.myipbxid].xod_config['users']
        if global_zone != self.global_zone:
            log.info('Global zone changed to %s', global_zone)
            for userid, user in userlist.keeplist.iteritems():
                alarmclock = user['alarmclock']
                if alarmclock and not user['timezone']:
                    self.alarm_mgr.test_update_alarm_clock(int(userid), alarmclock, global_zone)
            self.global_zone = global_zone
        if userlist.alarm_clk_changes:
            for userid, (alarmclock, zone) in userlist.alarm_clk_changes.iteritems():
                log.info('Alarm clock changed for user %s', userid)
                if not zone:
                    zone = global_zone
                self.alarm_mgr.test_update_alarm_clock(int(userid), alarmclock, zone) 
            userlist.alarm_clk_changes.clear()
        
    def select_step(self):  # {
        self._schedule_alarms()
        
        try:    # {
            fdtodel = []
            for cn in self.fdlist_established.keys():
                if isinstance(cn, ClientConnection):
                    if cn.isClosed and cn not in fdtodel:
                        fdtodel.append(cn)
                    if cn.toClose and not cn.need_sending():
                        cn.close()
                        if cn not in fdtodel:
                            fdtodel.append(cn)
            if fdtodel:
                log.warning('there are fd to delete : %s' % fdtodel)
                for cn in fdtodel:
                    del self.fdlist_established[cn]

            self.fdlist_full = list()
            self.fdlist_full.append(self.pipe_queued_threads[0])
            # put AMI fd's before FAGI ones in order to be properly synced
            self.fdlist_full.extend(self.fdlist_ami.keys())
            self.fdlist_full.extend(self.fdlist_listen_cti.keys())
            self.fdlist_full.extend(self.fdlist_udp_cti.keys())
            self.fdlist_full.extend(self.fdlist_established.keys())
            self.fdlist_full.extend(self.fdlist_remote_cti.keys())
            writefds = []
            for iconn, kind in self.fdlist_established.iteritems():
                if kind in ['CTI', 'CTIS'] and iconn.need_sending():
                    writefds.append(iconn)
            [sels_i, sels_o, sels_e] = select.select(self.fdlist_full, writefds, [],
                                                     self.updates_period())
        # }
        except Exception:  # {
            log.exception('(select) probably Ctrl-C or daemon stop or daemon restart ...')
            log.warning('(select) self.askedtoquit=%s fdlist_full=%s'
                        % (self.askedtoquit, self.fdlist_full))
            log.warning('(select) current open TCP connections : (CTI, WEBI, FAGI, INFO) %s'
                        % self.fdlist_established)
            log.warning('(select) current open TCP connections : (AMI) %s'
                        % self.fdlist_ami.keys())
            log.warning('(select) current open TCP connections : (RCTI) %s'
                        % self.fdlist_remote_cti.keys())
            
            # we must close the scheduler early since scheduled jobs depends
            # on the AMI connection
            self.scheduler.shutdown()
            
            for s in self.fdlist_full:
                if s in self.fdlist_established:
                    if self.askedtoquit:
                        self.fdlist_established[s].disconnected('stop')
                    else:
                        self.fdlist_established[s].disconnected('reload')
                if not isinstance(s, int):
                    # the only one 'int' is the (read) pipe : no need to close/reopen it
                    s.close()

            if self.askedtoquit:
                # self.commandclass.reset('stop') # used to call __fill_ctilog__('daemon stop', mode)
                time_uptime = int(time.time() - time.mktime(self.time_start))
                log.info('# STOPPING XiVO CTI Server %s (pid %d) / git:%s # uptime %d s (since %s)'
                         % (self.xivoversion, os.getpid(), self.revision,
                            time_uptime, time.asctime(self.time_start)))
                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                    print '--- (stop) killing thread <%s>' % t.getName()
                    t._Thread__stop()
                daemonize.unlock_pidfile(PIDFILE)
                sys.exit(5)
            else:
                # self.commandclass.reset('reload')
                self.askedtoquit = True
                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                    print '--- (reload) the thread <%s> remains' % t.getName()
                    # t._Thread__stop() # does not work in reload case (vs. stop case)
                return
        # }
        try:    # {
            # connexions ready for sending(writing)
            if sels_o:
                log.warning('got some sels_o %s' % sels_o)
            for sel_o in sels_o:
                try:
                    sel_o.process_sending()
                except ClientConnection.CloseException, cexc:
                    if sel_o in self.fdlist_established:
                        kind = self.fdlist_established[sel_o]
                        log.info('TCP socket %s closed(sending %s) on %s'
                                 % (kind, cexc, sel_o.getpeername()))
                        kind.disconnected('end_sending')
                        sel_o.close()
                        del self.fdlist_established[sel_o]

            if sels_e:
                log.warning('got some sels_e %s' % sels_e)

            if sels_i:  # {
                for sel_i in sels_i: # {
                    # these AMI connections are used in order to manage AMI commands and events
                    if sel_i in self.fdlist_ami.keys():
                        try:
                            amiint = self.fdlist_ami.get(sel_i)
                            ipbxid = amiint.ipbxid
                            buf = sel_i.recv(BUFSIZE_LARGE)
                            if len(buf) == 0:
                                log.warning('AMI %s : CLOSING (%s)' % (ipbxid, time.asctime()))
                                del self.fdlist_ami[sel_i]
                                sel_i.close()
                                amiint.disconnect()
                            else:
                                try:
                                    amiint.handle_event(buf)
                                except Exception:
                                    log.exception('(handle_event) %s' % ipbxid)
                        except Exception:
                            log.exception('(amilist)')

                    elif sel_i in self.fdlist_remote_cti.keys():
                        try:
                            cticonn = self.fdlist_remote_cti.get(sel_i)
                            ipbxid = cticonn.ipbxid
                            buf = sel_i.recv(BUFSIZE_LARGE)
                            if len(buf) == 0:
                                log.warning('RCTI %s : CLOSING' % ipbxid)
                                del self.fdlist_remote_cti[sel_i]
                                sel_i.close()
                                cticonn.disconnect()
                            else:
                                try:
                                    cticonn.handle_event(buf)
                                except Exception:
                                    log.exception('(handle_event) %s' % ipbxid)
                        except Exception:
                            log.exception('(remotecti)')

                    # } the UDP messages (ANNOUNCE) are catched here
                    elif sel_i in self.fdlist_udp_cti: # {
                        [kind, nmax] = self.fdlist_udp_cti[sel_i].split(':')
                        if kind == 'ANNOUNCE':
                            [data, sockparams] = sel_i.recvfrom(BUFSIZE_LARGE)
                            log.info('UDP %s <%s> %s' % (kind, data.strip(), sockparams))
                            # scheduling AMI reconnection
                            k = threading.Timer(1, self.cb_timer,
                                                ({'action' : 'ipbxup',
                                                  'properties' : { 'data' : data,
                                                                   'sockparams' : sockparams }},))
                            k.setName('Thread-ipbxup-%s' % data.strip())
                            k.start()
                        else:
                            log.warning('unknown kind %s received' % kind)

                    # } the new TCP connections (CTI, WEBI, FAGI, INFO) are catched here
                    elif sel_i in self.fdlist_listen_cti: # {
                        [kind, nmax] = self.fdlist_listen_cti[sel_i].split(':')
                        [connc, sockparams] = sel_i.accept()
                        ctiseparator = '\n'
                        log.info('TCP socket %s opened on %s:%d' % (kind,
                                                                    sockparams[0], sockparams[1]))

                        if kind == 'CTI':
                            connc = ClientConnection(connc, sockparams, ctiseparator)
                        elif kind == 'CTIS':
                            try:
                                connstream = ssl.wrap_socket(connc,
                                                             server_side = True,
                                                             certfile = self.cconf.getconfig('certfile'),
                                                             keyfile = self.cconf.getconfig('keyfile'),
                                                             ssl_version = SSLPROTO)
                                connc = ClientConnection(connstream, sockparams, ctiseparator)
                            except ssl.SSLError, exc:
                                log.exception('%s:%s:%d cert=%s key=%s)'
                                              % (kind, sockparams[0], sockparams[1],
                                                 self.cconf.getconfig('certfile'),
                                                 self.cconf.getconfig('keyfile')))
                                connc.close()
                                connc = None
                        # appending the opened socket to the ones watched
                        # connc.setblocking(0)
                        # connc.settimeout(2)
                        if connc:
                            if kind == 'INFO':
                                nc = interface_info.INFO(self)
                            elif kind == 'WEBI':
                                nc = interface_webi.WEBI(self)
                            elif kind in ['CTI', 'CTIS']:
                                nc = getattr(interface_cti, kind)(self)
                            elif kind == 'FAGI':
                                nc = interface_fagi.FAGI(self)

                            nc.connected(connc)
                            if kind in ['WEBI', 'FAGI', 'INFO']:
                                ipbxid = self.find_matching_ipbxid(sockparams[0])
                                ipbxid = self.myipbxid
                                if ipbxid:
                                    nc.set_ipbxid(ipbxid)
                                else:
                                    log.warning('(%s interface) did not find a matching ipbxid for %s'
                                                % (kind, sockparams[0]))

                            if kind in ['CTI', 'CTIS']:
                                logintimeout = int(self.cconf.getconfig('main').get('logintimeout', 5))
                                # logintimeout = 3600
                                nc.logintimer = threading.Timer(logintimeout, self.cb_timer,
                                                                ({'action' : 'ctilogin',
                                                                  'properties' : connc},))
                                nc.logintimer.start()
                            self.fdlist_established[connc] = nc
                        else:
                            log.warning('connc is not defined ...')

                    # } incoming TCP connections (CTI, WEBI, AGI, INFO)
                    elif sel_i in self.fdlist_established: # {
                        try: # {
                            kind = self.fdlist_established[sel_i]
                            requester = '%s:%d' % sel_i.getpeername()[:2]
                            closemenow = False
                            if isinstance(sel_i, ClientConnection):
                                try:
                                    lines = sel_i.readlines()
                                    for line in lines:
                                        if line:
                                            closemenow = self.manage_tcp_connections(sel_i, line, kind)
                                except ClientConnection.CloseException, cexc:
                                    kind.disconnected('end_receiving')
                                    # don't close since it has been done
                                    del self.fdlist_established[sel_i]
                                    # if requester in self.commandclass.transfers_ref:
                                    #   self.commandclass.transfer_endbuf(requester)
                                    log.info('TCP socket %s closed(A %s) on %s' % (kind.kind, cexc, requester))
                            else: # {
                                try:
                                    msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                    lmsg = len(msg)
                                except Exception:
                                    log.exception('connection to %s (%s)' % (requester, kind))
                                    lmsg = 0

                                if lmsg > 0:
                                    try:
                                        closemenow = self.manage_tcp_connections(sel_i, msg, kind)
                                    except Exception:
                                        log.exception('handling %s (%s)' % (requester, kind))
                                else:
                                    closemenow = True
                                    # XXX connc : kind.manage_logout('end_receiving')

                            if closemenow:
                                kind.disconnected('by_client')
                                sel_i.close()
                                del self.fdlist_established[sel_i]
                                # if requester in self.commandclass.transfers_ref:
                                #   self.commandclass.transfer_endbuf(requester)
                                log.info('TCP socket %s closed(B) on %s' % (kind.kind, requester))
                            # }
                        # }
                        except Exception:
                            # socket.error : exc.args[0]
                            log.exception('[%s] %s' % (kind, sel_i))
                            try:
                                log.warning('unexpected socket breakup')
                                kind.disconnected('exception')
                                sel_i.close()
                                del self.fdlist_established[sel_i]
                            except Exception:
                                log.exception('[%s] (2nd exception)' % kind)

                    # }
                    # local pipe fd
                    elif self.pipe_queued_threads[0] == sel_i: # {
                        try:
                            pipebuf = os.read(sel_i, 1024)
                            if len(pipebuf) == 0:
                                log.warning('pipe_queued_threads has been closed')
                            else:
                                for pb in pipebuf.split('\n'):
                                    if not pb:
                                        continue
                                    [kind, where] = pb.split(':')
                                    if kind in ['main', 'innerdata', 'ami']:
                                        if kind == 'main':
                                            nactions = self.checkqueue()
                                        elif kind == 'innerdata':
                                            nactions = self.safe[where].checkqueue()
                                        elif kind == 'ami':
                                            nactions = self.myami[where].checkqueue()
                                        log.info('handled %d actions for %s' % (nactions, kind))
                                    elif kind == 'alarmclk':
                                        userid = where
                                        params = {'amicommand': 'alarmclk',
                                                  'amiargs': (userid,)}
                                        self.myami[self.myipbxid].execute_and_track(None, params)
                                    else:
                                        log.warning('unknown kind for %s' % pb)
                        except Exception:
                            log.exception('[pipe_queued_threads]')

                    # }

                    self.loop_over_cti_queues()

                    for ipbxid, safe in self.safe.iteritems():
                      if ipbxid == self.myipbxid:
                        if (time.time() - self.lastrequest_time[ipbxid]) > self.updates_period() or self.update_userlist[ipbxid]:
                            self.lastrequest_time[ipbxid] = time.time()
                            log.info('[%s] %s : updates (computed timeout) %s (%s)'
                                     % (self.xdname, ipbxid, time.asctime(), self.update_userlist[ipbxid]))
                            try:
                                # manage_connection.update_amisocks(ipbxid, self)
                                self.cconf.update()
                                safe.regular_update()
                            except Exception:
                                log.exception('%s : failed while updating lists and sockets (computed timeout)'
                                              % ipbxid)
                            try:
                                if self.update_userlist[ipbxid]:
                                    while self.update_userlist[ipbxid]:
                                        tmp_ltr = self.update_userlist[ipbxid].pop()
                                        if tmp_ltr != 'xivo[cticonfig,update]':
                                            listtorequest = tmp_ltr[5:-12] + 's'
                                            safe.update_config_list(listtorequest)
                                else:
                                    safe.update_config_list_all()
                            except Exception:
                                log.exception('%s : commandclass.updates() (computed timeout)' % ipbxid)
                      else:
                          pass
                    # }
                # }
            # }

            if not sels_i and not sels_o and not sels_e:
                # when nothing happens on the sockets, we fall here
                log.info('[%s] updates (select timeout) %s' % (self.xdname, time.asctime()))
                for ipbxid, safe in self.safe.iteritems():
                  if ipbxid == self.myipbxid:
                    try:
                        safe.update_config_list_all()
                    except Exception:
                        log.exception('%s : commandclass.updates() (select timeout)' % ipbxid)

                    self.lastrequest_time[ipbxid] = time.time()

                    try:
                        # manage_connection.update_amisocks(ipbxid, self)
                        self.cconf.update()
                        safe.regular_update()
                    except Exception:
                        log.exception('%s : failed while updating lists and sockets (select timeout)' % ipbxid)
                  else:
                      pass
            # }
        # }
        except Exception:
            log.exception('select step')
    # }

if __name__ == '__main__':
    parse_command_line()
    if XIVOIP != 'localhost':
        XIVO_CONF_FILE = 'https://%s/cti/json.php/restricted/configuration' % XIVOIP
    main = ctiserver()
