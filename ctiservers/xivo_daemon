#!/usr/bin/python
# vim: set fileencoding=utf-8 :

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Alternatively, XiVO CTI Server is available under other licenses directly
# contracted with Pro-formatique SARL. See the LICENSE file at top of the
# source tree or delivered in the installable package in which XiVO CTI Server
# is distributed for more details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


__version__   = '$Revision$'
__date__      = '$Date$'
__copyright__ = 'Copyright (C) 2007-2011 Proformatique'
__author__    = 'Corentin Le Gall'

"""
# 1) General description of XiVO CTI Server
# The XiVO CTI Server is a general-purpose daemon, whose basic features are :
#  - the monitoring of one or more Asterisk, through AMI
#  - taking care of Asteriks AGI requests
#  - the ability to receive incoming "CTI clients" connections
#  - the ability to relay commands (between a Web interface and Asterisk)
#  - the connection to one or more databases (cdr, directory, ...)
#  - the connection to a given server
# 
# 2) Primary data structures
# 
#  - users list
#  - contexts/companies list
# 
#  - asterisk / configurations
#  - phonelist
#
# 3) Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks)
# - the incoming TCP sockets (CTI, WEBI, INFO, (F)AGI)
#
# 4) Custom-defined Plugins
#
"""

# debian.org modules
import getopt
from optparse import OptionParser
import os
import pickle
import select
import signal
import socket
import string
import sys
import threading
import time
import logging
from logging.handlers import RotatingFileHandler
import Queue
from xivo_ctiservers.client_connection import ClientConnection

# XIVO CTI modules
from xivo_agid import fastagi
from xivo_ctiservers import xivo_ami
from xivo_ctiservers import xivo_contexts
from xivo_ctiservers import xivo_astcfg
from xivo_ctiservers import cti_config
from xivo_ctiservers import xivo_commandsets
from xivo_ctiservers.CommandSets import *
from xivo_ctiservers.xivo_commandsets import ctidaemonize as daemonize
from xivo_ctiservers import interface_info

__alphanums__ = string.uppercase + string.lowercase + string.digits
waiting_actionid = {}
waiting_actionid_timer = {}

LOGDAEMONNAME = 'ctid'
try:
    DAEMONNAME = os.path.basename(sys.argv[0])
except:
    DAEMONNAME = 'ctid'

# XIVO lib-python modules initialization
#XIVO_CONF_FILE   = '/etc/pf-xivo/ctiservers/xivo_daemon.conf'
XIVO_CONF_FILE_DEFAULT = 'file:///etc/pf-xivo/ctiservers/ctiserver_default_configuration.json'
XIVO_CONF_FILE         = 'https://localhost/service/ipbx/json.php/private/ctiserver/configuration'
PIDFILE            = '/var/run/%s.pid' % DAEMONNAME
LOGFILENAME        = '/var/log/pf-xivo-cti-server/daemon.log'
GETOPT_SHORTOPTS   = 'dc:p:l:'
GETOPT_LONGOPTS    = ['debug', 'config=', 'pidfile=', 'logfile=']
debug_mode = False

BUFSIZE_LARGE = 8192
BUFSIZE_ANY = 512

XIVO_CLI_WEBI_HEADER = 'XIVO-CLI-WEBI'

def parse_command_line():
    global XIVO_CONF_FILE, PIDFILE, LOGFILENAME, debug_mode
    for opt, arg in getopt.getopt( sys.argv[1:], GETOPT_SHORTOPTS, GETOPT_LONGOPTS)[0]:
        if opt == '-c':
            XIVO_CONF_FILE = arg
        elif opt == '-d':
            debug_mode = True
        elif opt == '-p':
            PIDFILE = arg
        elif opt == '-l':
            LOGFILENAME = arg

class manage_connection:
    ## \brief Deals with requests from the UI clients.
    # \param connid connection identifier
    # \param msg message to process
    # \param sep separator to split the message
    # \return none
    @staticmethod
    def manage_cti_connections(daemon, connid, msg, sep):
        """
        Handles CTI connections.
        """
        requester = '%s:%d' % connid.getpeername()
        if requester in daemon.commandclass.transfers_ref:
            daemon.commandclass.transfer_addbuf(requester, msg)
            return

        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
            # remove tailing \r
            usefulmsg = usefulmsgpart.split('\r')[0]
            if len(usefulmsg) == 0:
                break
            command = daemon.commandclass.parsecommand(usefulmsg)
            if command.name in daemon.commandclass.get_list_commands():
                try:
                    commandtype_list = [xivo_commandsets.CMD_LOGIN_ID,
                                        xivo_commandsets.CMD_LOGIN_PASS,
                                        xivo_commandsets.CMD_LOGIN_CAPAS]
                    if command.type in commandtype_list:
                        # log.info('LOGIN(%s) %s : args   %s' % (command.type, requester, command.args))
                        loginparams = daemon.commandclass.get_login_params(command, daemon.asterisklist[0], connid)
                        # log.info('LOGIN(%s) %s : params %s' % (command.type, requester, loginparams))
                        uinfo = daemon.commandclass.manage_login(loginparams, command.type, daemon.userinfo_current.get(connid))
                        # log.info('LOGIN(%s) %s : uinfo  %s' % (command.type, requester, uinfo))

                        if isinstance(uinfo, str):
                            daemon.commandclass.loginko(loginparams, uinfo, connid)
                            log.info('TCP socket %s closed(loginko) on %s' % (daemon.fdlist_established[connid],
                                                                              '%s:%d' % connid.getpeername()))
                            del daemon.fdlist_established[connid]
                            connid.close()
                        else:
                            if command.type == xivo_commandsets.CMD_LOGIN_CAPAS:
                                uinfo['login']['connection'] = connid
                                daemon.userinfo_by_requester[connid] = uinfo
                                if connid in daemon.userinfo_current:
                                    del daemon.userinfo_current[connid]
                            else:
                                daemon.userinfo_current[connid] = uinfo
                            daemon.commandclass.loginok(loginparams, uinfo, connid, command.type)
                    elif command.type == xivo_commandsets.CMD_TRANSFER:
                        log.info('TRANSFER on %s : %s' % (requester, command.struct))
                        daemon.commandclass.transfer_addref(connid, command.struct)
                    else:
                        if connid in daemon.userinfo_by_requester:
                            daemon.commandclass.manage_cticommand(daemon.userinfo_by_requester[connid], command)
                        else:
                            log.warning('unlogged %s is attempting a %s (TCP) : %s'
                                        % (requester, command.name, command.args))
                except Exception:
                    log.exception('CTI connection when managing [%s, %s] for %s'
                                  % (command.name, command.type, requester))
            else:
                connid.sendall('Unknown Command <%s>\n' % command.name)


    ## \brief Deals with requests from the UI clients.
    # \param connid connection identifier
    # \return none
    @staticmethod
    def manage_webi_connections(daemon, connid, msg, sep):
        """
        Handles WEBI connections.
        """
        requester = '%s:%d' % connid.getpeername()
        requester_ip = connid.getpeername()[0]
        closemenow = True

        if requester_ip not in daemon.ip_reverse_webi:
            connid.sendall('%s:KO <NOT ALLOWED FROM %s>\n' % (XIVO_CLI_WEBI_HEADER, requester_ip))
            return closemenow
        astid = daemon.ip_reverse_webi[requester_ip]

        multimsg = msg.split(sep)
        for usefulmsgpart in multimsg:
            usefulmsg = usefulmsgpart.split('\r')[0]
            if len(usefulmsg) == 0:
                break
            try:
                xivocmd_update_list = ['xivo[userlist,update]',
                                       'xivo[meetmelist,update]',
                                       'xivo[agentlist,update]',
                                       'xivo[queuelist,update]',
                                       'xivo[grouplist,update]']
                if usefulmsg in xivocmd_update_list:
                    if usefulmsg not in daemon.update_userlist[astid]:
                        daemon.update_userlist[astid].append(usefulmsg)
                        log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                    else:
                        log.info('%s : WEBI re-requested %s (%s)' % (astid, usefulmsg, requester))
                elif usefulmsg == 'xivo[daemon,reload]':
                    daemon.askedtoquit = True
                    log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                elif usefulmsg == 'xivo[ctiprofilelist,get]':
                    log.info('%s : WEBI requested %s (%s)' % (astid, usefulmsg, requester))
                    connid.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                    connid.sendall('%s\n' % daemon.commandclass.getprofilelist())
                    connid.sendall('%s:OK\n' % XIVO_CLI_WEBI_HEADER)
                elif astid in daemon.amilist.ami and daemon.amilist.ami[astid]:
                    stripped_usefulmsg = usefulmsg.strip()
                    try:
                        if stripped_usefulmsg == 'moh reload':
                            daemon.commandclass.pre_moh_reload()
                        elif stripped_usefulmsg == 'reload':
                            daemon.commandclass.pre_reload()
                    except Exception:
                        log.exception('(pre reloads (%s))' % stripped_usefulmsg)

                    closemenow = False

                    try:
                        actionid = daemon.amilist.execute(astid, 'sendcommand', 'Command', [('Command', stripped_usefulmsg)])
                        log.info('%s : WEBI requested a <%s> with actionid %s (%s)' % (astid, stripped_usefulmsg, actionid, connid))

                        waiting_actionid[actionid] = connid
                        waiting_actionid_timer[actionid] = threading.Timer(5, manage_connection.callback_timer_main,
                                                                           (daemon, ('webirequest', actionid)))
                        waiting_actionid_timer[actionid].start()
                    except Exception, exc:
                        log.error('(%s) WEBI command exec <%s> : (client %s) : %s'
                                  % (astid, stripped_usefulmsg, requester, exc))
            except Exception, exc:
                log.error('(%s) WEBI <%s> : (client %s) : %s'
                          % (astid, usefulmsg.strip(), requester, exc))
                connid.sendall('%s:KO <Exception : %s>\n' % (XIVO_CLI_WEBI_HEADER, exc))
        return closemenow

    @staticmethod
    def manage_tcp_connections(daemon, sel_i, msg, kind):
        """
        Dispatches the message's handling according to the connection's kind.
        """
        closemenow = True
        if kind == 'CTI':
            manage_connection.manage_cti_connections(daemon, sel_i, msg, daemon.commandclass.ctiseparator)
        elif kind == 'WEBI':
            closemenow = manage_connection.manage_webi_connections(daemon, sel_i, msg, '\n')
        elif kind == 'AGI':
            agireply = daemon.commandclass.handle_agi(daemon.asterisklist[0], msg)
            if agireply is not None:
                sel_i.sendall(agireply)
        elif not isinstance(kind, str):
            kind.manage_connection(daemon, msg)
        else:
            log.warning('unknown connection kind %s' % kind)
        return closemenow


    """
    Management of events that are spied on the AMI
    """
    ## \brief Handling of AMI events occuring in Events=on mode.
    # \param astid the asterisk Id
    # \param idata the data read from the AMI we want to parse
    # \return none
    @staticmethod
    def handle_ami_event(daemon, astid, idata):
        """
        Handles the AMI events occuring on Asterisk.
        If the Event field is there, calls the handle_ami_function() function.
        """
        if astid not in daemon.configs:
            log.info('%s : no such asterisk Id' % astid)
            return

        full_idata = daemon.save_for_next_packet_events[astid] + idata
        evlist = full_idata.split('\r\n\r\n')
        daemon.save_for_next_packet_events[astid] = evlist.pop()

        for ievt in evlist:
            try:
                evt = ievt.decode('utf8')
            except Exception:
                log.exception('%s could not decode event %r' % (astid, ievt))
                continue
            this_event = {}
            nocolon = []
            for myline in evt.split('\r\n'):
                if myline.find('\n') < 0:
                    if myline != '--END COMMAND--': # occurs when requesting "module reload xxx.so" for instance
                        myfieldvalue = myline.split(': ', 1)
                        if len(myfieldvalue) == 2:
                            this_event[myfieldvalue[0]] = myfieldvalue[1]
                        else:
                            if myline.startswith('Asterisk Call Manager'):
                                log.info('%s : %s' % (astid, myline))
                            elif myline == 'ReportBlock:':
                                # single line in RTCPSent events - ignoring it for the time being
                                pass
                            else:
                                log.warning('%s unable to parse <%s> : %s'
                                            % (astid, myline, evt.split('\r\n')))
                else:
                    nocolon.append(myline)

            if len(nocolon) > 1:
                log.warning('%s nocolon is %s' % (astid, nocolon))

            evfunction = this_event.pop('Event', None)
            # log.info('%s AMI(all)  %s  : %s' % (astid, evfunction, this_event))
            if evfunction is not None:
                for ik, iv in daemon.fdlist_established.iteritems():
                    if not isinstance(iv, str) and iv.dumpami_enable:
                        todisp = this_event
                        efn = evfunction
                        if iv.dumpami_enable == ['all'] or efn in iv.dumpami_enable:
                            doallow = True
                            if iv.dumpami_disable and efn in iv.dumpami_disable:
                                doallow = False
                            if doallow:
                                ik.sendall('%.3f %s %s %s\n' % (time.time(), astid, efn, todisp))
                manage_connection.handle_ami_function(daemon, astid, evfunction, this_event)

                if evfunction not in ['Newexten', 'Newchannel', 'Newstate', 'Newcallerid']:
                    pass
                    # verboselog('%s %s' % (astid, this_event), True, False)
            else: # {
                response = this_event.get('Response')

                if response is not None:
                    if response == 'Follows' and this_event.get('Privilege') == 'Command':
                        if 'ActionID' in this_event:
                            actionid = this_event.get('ActionID')
                            connreply = waiting_actionid.get(actionid)
                            try:
                                if connreply is not None:
                                    connreply.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                for noc in nocolon:
                                    arggs = noc.split('\n')
                                    for toremove in ['', '--END COMMAND--']:
                                        while toremove in arggs:
                                            arggs.remove(toremove)
                                    if arggs:
                                        if connreply is not None:
                                            log.info('%s AMI Response : %s : %s' % (astid, actionid, arggs))
                                            for argg in arggs:
                                                connreply.sendall(argg + '\n')
                                if connreply is not None:
                                    connreply.sendall('%s:OK\n' % XIVO_CLI_WEBI_HEADER)
                                    log.info('TCP socket %s closed(actionid-ok) on %s'
                                             % (daemon.fdlist_established[connreply],
                                                '%s:%d' % connreply.getpeername()))
                                    del daemon.fdlist_established[connreply]
                                    connreply.close()
                                    del waiting_actionid[actionid]
                                    waiting_actionid_timer[actionid].cancel()
                                    del waiting_actionid_timer[actionid]
                            except Exception, e:
                                log.exception('%s (command reply to %s, %s)' % (astid, connreply, actionid))
                                print e
                        try:
                            daemon.commandclass.amiresponse_follows(astid, this_event, nocolon)
                        except Exception:
                            log.exception('%s amiresponse_follows (%s) (%s)' % (astid, this_event, nocolon))
                    elif response == 'Success':
                        try:
                            daemon.commandclass.amiresponse_success(astid, this_event, nocolon)
                        except Exception:
                            log.exception('%s amiresponse_success (%s) (%s)' % (astid, this_event, nocolon))
                    elif response == 'Error':
                        if 'ActionID' in this_event:
                            actionid = this_event.get('ActionID')
                            connreply = waiting_actionid.get(actionid)
                            try:
                                if connreply is not None:
                                    connreply.sendall('%s:ID <%s>\n' % (XIVO_CLI_WEBI_HEADER, astid))
                                    connreply.sendall('%s:KO\n' % XIVO_CLI_WEBI_HEADER)
                                    log.info('TCP socket %s closed(actionid-ko) on %s'
                                             % (daemon.fdlist_established[connreply],
                                                '%s:%d' % connreply.getpeername()))
                                    del daemon.fdlist_established[connreply]
                                    connreply.close()
                                    del waiting_actionid[actionid]
                                    waiting_actionid_timer[actionid].cancel()
                                    del waiting_actionid_timer[actionid]
                            except Exception:
                                log.exception('%s (command reply to %s, %s)' % (astid, connreply, actionid))
                        try:
                            daemon.commandclass.amiresponse_error(astid, this_event, nocolon)
                        except Exception:
                            log.exception('%s amiresponse_error (%s) (%s)' % (astid, this_event, nocolon))
                    else:
                        log.warning('AMI %s Response=%s (untracked) : %s' % (astid, response, this_event))

                elif len(this_event) > 0:
                    log.warning('AMI:XXX: <%s> : %s' % (astid, this_event))
                else:
                    log.warning('AMI %s Other : %s' % (astid, this_event))
            # }
        nevts = len(evlist)
        if nevts > 200:
            log.info('%s : handled %d (> 200) events' % (astid, nevts))

    @staticmethod
    def handle_ami_function(daemon, astid, evfunction, this_event):
        """
        Handles the AMI events related to a given function (i.e. containing the Event field).
        It roughly only dispatches them to the relevant commandset's methods.
        """
        try:
            if 'Privilege' in this_event:
                this_event.pop('Privilege')
            if (evfunction in xivo_ami.evfunction_to_method_name):
                methodname = xivo_ami.evfunction_to_method_name.get(evfunction)
                if hasattr(daemon.commandclass, methodname):
                    getattr(daemon.commandclass, methodname)(astid, this_event)
                else:
                    log.warning('%s AMI ... this event (%s) is tracked but no %s method is defined : %s'
                                % (astid, evfunction, methodname, this_event))
            else:
                log.warning('%s AMI ... this event (%s) is not tracked : %s'
                            % (astid, evfunction, this_event))

        except Exception:
            log.exception('%s AMI / %s : event %s' % (astid, evfunction, this_event))


    @staticmethod
    def update_amisocks(astid, daemon):
        """
        Connects to the Asterisk's AMI (defined by astid) if not yet done.
        Requests a Status when it (re)connects.
        """
        try:
            daemon.amilist.setconfig(astid,
                                     (daemon.configs[astid].remoteaddr,
                                      daemon.configs[astid].ami_port),
                                     daemon.configs[astid].ami_login,
                                     daemon.configs[astid].ami_pass)
            daemon.amilist.connect(astid)

        except Exception:
            log.exception('%s (update_amisocks) %s:%d'
                          % (astid, daemon.configs[astid].remoteaddr, daemon.configs[astid].ami_port))
        return


    @staticmethod
    def callback_timer_main(*args):
        try:
            thisthread = threading.currentThread()
            daemon = args[0]
            tname = thisthread.getName()
            log.info('callback_timer_main (timer finished at %s) %s %s' % (time.asctime(), tname, args))
            thisthread.setName(tname + '-' + '-'.join(args[1]))
            daemon.tqueue.put(thisthread)
            os.write(daemon.pipe_queued_threads_main[1], thisthread.getName())
        except Exception:
            log.exception('callback_timer_main %s' % args)
        return

    @staticmethod
    def checkqueue_main(daemon, buf):
        log.info('checkqueue_main : read buf = %s, tqueue size = %d' % (buf, daemon.tqueue.qsize()))
        while daemon.tqueue.qsize() > 0:
            thisthread = daemon.tqueue.get()
            if len(thisthread.args) > 1 and len(thisthread.args[1]) > 1:
                action = thisthread.args[1][0]
                if action == 'ipbxup':
                    # check whether the AMI is already connected,
                    # and connects if needed
                    astid = thisthread.args[1][1]
                    manage_connection.update_amisocks(astid, daemon)
                elif action == 'webirequest':
                    # checks whether the given actionid is still ongoing and closes
                    # the related WEBI request then
                    actionid = thisthread.args[1][1]
                    if actionid in waiting_actionid and actionid in waiting_actionid_timer:
                        conn_to_close = waiting_actionid[actionid]
                        log.info('closing the WEBI connection %s for the request %s'
                                 % (conn_to_close, actionid))
                        del daemon.fdlist_established[conn_to_close]
                        conn_to_close.close()
                        del waiting_actionid[actionid]
                        del waiting_actionid_timer[actionid]
                    else:
                        log.warning('the actionid %s has gone' % actionid)
                else:
                    log.warning('unknown action <%r>' % action)
            else:
                log.warning('malformed tqueue : not enough arguments in %s' % thisthread.args)
        return



class xivo_daemon:
    xivoversion = '1.2'
    revision = __version__.split()[1]

    def __init__(self):
        # print sys.getdefaultencoding()
        logging.basicConfig(level = logging.INFO)
        #logging.basicConfig(level = logging.DEBUG)

        global log

        log = logging.getLogger('main')

        try:
            logfilehandler = RotatingFileHandler(LOGFILENAME)
            formatter = logging.Formatter('%%(asctime)s %s[%%(process)d] (%%(levelname)s) (%%(name)s): %%(message)s'
                                          % LOGDAEMONNAME)
            logfilehandler.setFormatter(formatter)
            logging.getLogger('').addHandler(logfilehandler)

        except Exception:
            log.exception('logfilehandler')

        if not debug_mode:
            daemonize.daemonize()

        daemonize.lock_pidfile_or_die(PIDFILE)

        signal.signal(signal.SIGINT, self.sighandler)
        signal.signal(signal.SIGTERM, self.sighandler)
        signal.signal(signal.SIGHUP, self.sighandler_reload)

        self.nreload = 0
        self.contextlist = xivo_contexts.Contexts()
        self.configs = {}
        self.xdname = None
        self.tqueue = Queue.Queue()
        self.pipe_queued_threads_commandclass = None
        self.pipe_queued_threads_main = None

        while True:
            try:
                self.main_loop()
            except Exception:
                # this will occur at server startup, when WEBI is not started yet
                # XXX this is a very naughty way, however, to handle that
                log.exception('main loop has crashed ... retrying in 5 seconds ...')
                time.sleep(5)

    ## \brief Handler for catching signals (in the main thread)
    # \param signum signal number
    # \param frame frame
    # \return none
    def sighandler(self, signum, frame):
        log.warning('(sighandler) signal %s lineno %s (atq = %s) received : quits' % (signum, frame.f_lineno, self.askedtoquit))
        for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
            print '--- living thread <%s>' % (t.getName())
            t._Thread__stop()
        self.askedtoquit = True

    ## \brief Handler for catching signals (in the main thread)
    # \param signum signal number
    # \param frame frame
    # \return none
    def sighandler_reload(self, signum, frame):
        log.warning('(sighandler_reload) signal %s lineno %s (atq = %s) received : reloads' % (signum, frame.f_lineno, self.askedtoquit))
        self.askedtoquit = False

    def update_readconf(self):
        log.info('reparsing config file(s)')
        try:
            lconf = cti_config.Config(XIVO_CONF_FILE)
        except Exception:
            log.warning('could not access to normal config file %s, switching to default' % XIVO_CONF_FILE)
            lconf = cti_config.Config(XIVO_CONF_FILE_DEFAULT)
        self.commandclass.set_cticonfig(lconf)

    # loads the configuration for each asterisk
    def load_asterisk_conf(self):   # {
        for astid in self.asterisklist:
            xivoconf_asterisk = self.cconf.xc_json[astid]
            if xivoconf_asterisk:
                urllist = {}
                url_queuelog = None

                for listname in self.commandclass.weblist.keys():
                    fieldname = 'urllist_%s' % listname
                    if fieldname in xivoconf_asterisk:
                        urllist[listname] = xivoconf_asterisk[fieldname]
                    else:
                        urllist[listname] = []
                if 'url_queuelog' in xivoconf_asterisk:
                    url_queuelog = xivoconf_asterisk['url_queuelog']

                self.configs[astid] = xivo_astcfg.AsteriskConfig(astid, xivoconf_asterisk)
                ipaddress = self.configs[astid].remoteaddr
                ipaddress_webi = self.configs[astid].ipaddress_webi

                for ilist in self.commandclass.weblist.keys():
                    self.commandclass.set_urllist(astid, ilist, urllist[ilist])

                t1 = time.time()
                self.commandclass.read_queuelog(astid, url_queuelog)
                t2 = time.time()

                log.info('%s spent %f seconds to read queuelog file' % (astid, t2 - t1))

                if ipaddress not in self.ip_reverse_sht:
                    self.ip_reverse_sht[ipaddress] = astid
                else:
                    log.warning('WARNING - IP address already exists for asterisk <%s> - can not set it for <%s>' %
                                (self.ip_reverse_sht[ipaddress], astid))
                if ipaddress_webi not in self.ip_reverse_webi:
                    self.ip_reverse_webi[ipaddress_webi] = astid
                else:
                    log.warning('WARNING - IP address (WEBI) already exists for asterisk <%s> - can not set it for <%s>' %
                                (self.ip_reverse_webi[ipaddress_webi], astid))

                self.save_for_next_packet_events[astid] = ''
    # }

    def main_loop(self):    # {
        self.askedtoquit = False

        self.time_start = time.localtime()
        if self.nreload == 0:
            log.info('# STARTING XiVO CTI Server %s (pid %d) / svn:%s # (0/3) Starting' %
                     (self.xivoversion, os.getpid(), self.revision))
        else:
            log.info('# STARTING XiVO CTI Server %s (pid %d) / svn:%s # (0/3) Reloading (%d)' %
                     (self.xivoversion, os.getpid(), self.revision, self.nreload))
        self.nreload += 1

        # global default definitions
        incoming_tcp_ports = []
        incoming_udp_ports = []
        self.asterisklist = []
        userlists = []
        ctilog = None

        self.userinfo_by_requester = {}
        self.userinfo_current = {}

        try:
            self.cconf = cti_config.Config(XIVO_CONF_FILE)
        except Exception:
            log.warning('could not access to normal config file %s, switching to default' % XIVO_CONF_FILE)
            self.cconf = cti_config.Config(XIVO_CONF_FILE_DEFAULT)
        xivoconf_general = self.cconf.xc_json['main']

        # loads the general configuration
        self.commandset = xivoconf_general['commandset']
        for func in ['CTI', 'WEBI', 'FAGI', 'INFO']:
            fieldname = 'incoming_tcp_%s' % func.lower()
            if fieldname in xivoconf_general:
                bind_and_port = xivoconf_general[fieldname]
                if len(bind_and_port) > 1:
                    try:
                        incoming_tcp_ports.append('%d:%s:%s' % (int(bind_and_port[1]), func, bind_and_port[0]))
                    except Exception:
                        log.exception('%s definition' % fieldname)
        for func in ['ANNOUNCE']:
            fieldname = 'incoming_udp_%s' % func.lower()
            if fieldname in xivoconf_general:
                bind_and_port = xivoconf_general[fieldname]
                if len(bind_and_port) > 1:
                    try:
                        incoming_udp_ports.append('%d:%s:%s' % (int(bind_and_port[1]), func, bind_and_port[0]))
                    except Exception:
                        log.exception('%s definition' % fieldname)

        self.extraconn = xivoconf_general.get('extraconn', '')
        self.updates_period = int(xivoconf_general.get('updates_period', '60'))
        ctilog = xivoconf_general.get('ctilog_db_uri')
        socktimeout = xivoconf_general.get('sockettimeout', '2')
        logintimeout = int(xivoconf_general.get('logintimeout', '5'))
        self.apnoeafile = xivoconf_general.get('apnoeafile')
        prefixfile = xivoconf_general.get('prefixfile')
        parting_astid_context = xivoconf_general.get('parting_astid_context')
        if 'asterisklist' in xivoconf_general:
            self.asterisklist = xivoconf_general['asterisklist']
        if 'userlists' in xivoconf_general:
            userlists = xivoconf_general['userlists']

        socket.setdefaulttimeout(float(socktimeout))

        if not self.pipe_queued_threads_commandclass and not self.pipe_queued_threads_main:
            self.pipe_queued_threads_commandclass = os.pipe()
            self.pipe_queued_threads_main = os.pipe()

        self.amilist = xivo_ami.AMIList()
        if self.commandset in xivo_commandsets.CommandClasses:
            self.commandclass = xivo_commandsets.CommandClasses[self.commandset](self.amilist,
                                                                                 incoming_tcp_ports,
                                                                                 self.pipe_queued_threads_commandclass)
        else:
            self.commandclass = xivo_commandsets.BaseCommand()
            log.warning('# STARTING %s : no such commandset <%s>' % (xdname, self.commandset))

        self.xdname = self.commandclass.xdname

        log.info('# STARTING %s / svn:%s / %d' % (self.xdname, self.commandclass.version(), self.nreload))

        self.update_readconf()
        self.commandclass.set_userlist_urls(userlists)
        self.commandclass.set_contextlist(self.contextlist)
        self.commandclass.set_configs(self.configs)
        self.commandclass.set_ctilog(ctilog)
        self.commandclass.set_logintimeout(logintimeout)

        if self.apnoeafile:
            try:
                e = open(self.apnoeafile, 'r')
                torescue = pickle.loads(e.read())
                e.close()
                self.commandclass.apnoea_rescue(torescue)
            except:
                log.exception('read apnoea file %s' % apnoeafile)
        if prefixfile:
            self.commandclass.read_internatprefixes(prefixfile)
        if parting_astid_context:
            self.commandclass.set_partings(parting_astid_context)

        for contextname, contextdef in self.cconf.xc_json['contexts'].iteritems():
            displaysection = contextdef['display']
            self.contextlist.setdisplay(contextname, self.cconf.xc_json['displays'][displaysection[9:]])
            for dr in contextdef['directories']:
                try:
                    self.contextlist.update(contextname, dr,
                                            self.cconf.xc_json['directories'][dr[12:]])
                except Exception:
                    log.exception('unable to read directory config for %s' % dr)

        self.save_for_next_packet_events = {}
        self.ip_reverse_webi = {}
        self.ip_reverse_sht = {}

        self.load_asterisk_conf()

        self.outsock = self.commandclass.extrasock(self.extraconn)

        self.fdlist_established = {}
        self.fdlist_listen_cti = {}
        self.fdlist_udp_cti = {}
        self.update_userlist = {}
        self.lastrequest_time = {}

        log.info("the monitored asterisk's is/are : %s" % self.asterisklist)
        log.info('# STARTING %s # (1/2) AMI socket connections + fetch Web Services' % self.xdname)

        for astid in self.configs: # {
            try:
                self.update_userlist[astid] = []
                self.lastrequest_time[astid] = time.time()
                manage_connection.update_amisocks(astid, self)
            except Exception:
                log.exception('%s : failed while setting lists and sockets' % astid)

            try:
                self.commandclass.updates(astid, 'all') # all updates ...
            except Exception:
                log.exception('%s : commandclass.updates()' % astid)
        # }

        log.info('# STARTING %s # (2/2) listening sockets (CTI, WEBI, (F)AGI, INFO)' % self.xdname)
        # opens the listening socket for incoming (CTI, WEBI, (F)AGI, INFO) connections
        for portkind in incoming_tcp_ports:
            pk = portkind.split(':')
            port = pk[0]
            kind = 'INFO'
            bind = '127.0.0.1'
            nmax = '1'
            if len(pk) > 1:
                kind = pk[1].strip()
                if len(pk) > 2:
                    bind = pk[2].strip()
                    if len(pk) > 3:
                        nmax = pk[3].strip()
            UIsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            UIsock.bind((bind, int(port)))
            UIsock.listen(10)
            self.fdlist_listen_cti[UIsock] = '%s:%s' % (kind, nmax)

        for portkind in incoming_udp_ports:
            pk = portkind.split(':')
            port = pk[0]
            kind = 'INFO'
            bind = '127.0.0.1'
            nmax = '1'
            if len(pk) > 1:
                kind = pk[1].strip()
                if len(pk) > 2:
                    bind = pk[2].strip()
                    if len(pk) > 3:
                        nmax = pk[3].strip()
            UIsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            UIsock.bind((bind, int(port)))
            self.fdlist_udp_cti[UIsock] = '%s:%s' % (kind, nmax)

        # Main select() loop - Receive messages
        while not self.askedtoquit:
            self.select_step()
    # }

    def select_step(self):  # {
        try:    # {
            fdtodel = []
            for cn in self.fdlist_established.keys():
                if isinstance(cn, ClientConnection):
                    if cn.isClosed and cn not in fdtodel:
                        fdtodel.append(cn)
                    if cn.toClose and not cn.need_sending():
                        cn.close()
                        if cn not in fdtodel:
                            fdtodel.append(cn)
            if fdtodel:
                log.warning('there are fd to delete : %s' % fdtodel)
                for cn in fdtodel:
                    del self.fdlist_established[cn]
                    if cn in self.userinfo_by_requester:
                        del self.userinfo_by_requester[cn]

            self.fdlist_full = list()
            self.fdlist_full.append(self.pipe_queued_threads_commandclass[0])
            self.fdlist_full.append(self.pipe_queued_threads_main[0])
            self.fdlist_full.extend(self.fdlist_listen_cti.keys())
            self.fdlist_full.extend(self.fdlist_udp_cti.keys())
            self.fdlist_full.extend(self.fdlist_established.keys())
            self.fdlist_full.extend(self.amilist.fdlist())
            if self.outsock is not None:
                self.fdlist_full.append(self.outsock)
            writefds = []
            for iconn, kind in self.fdlist_established.iteritems():
                if kind == 'CTI' and iconn.need_sending():
                    writefds.append(iconn)
            [sels_i, sels_o, sels_e] = select.select(self.fdlist_full, writefds, [],
                                                     self.updates_period)
        # }
        except Exception:  # {
            log.exception('(select) probably Ctrl-C or daemon stop or daemon restart ...')
            log.warning('(select) self.askedtoquit=%s fdlist_full=%s'
                        % (self.askedtoquit, self.fdlist_full))
            log.warning('(select) current open TCP connections : (CTI, WEBI, (F)AGI, INFO) %s'
                        % self.fdlist_established)
            log.warning('(select) current open TCP connections : (AMI) %s'
                        % self.amilist.fdlist())
            log.warning('(select) current open TCP connections : (OUT) %s'
                        % self.outsock)

            if self.askedtoquit and self.apnoeafile:
                try:
                    tosave = self.commandclass.apnoea_tosave()
                    e = open(self.apnoeafile, 'w')
                    e.write(pickle.dumps(tosave))
                    e.close()
                except:
                    log.exception('write apnoea file %s' % self.apnoeafile)

            for s in self.fdlist_full:
                if s in self.fdlist_established and self.fdlist_established[s] == 'CTI':
                    if self.askedtoquit:
                        self.commandclass.reset('stop', s)
                    else:
                        self.commandclass.reset('reload', s)
                if isinstance(s, int):
                    # the only ones are the (read) pipes : no need to close/reopen them
                    # os.close(s)
                    pass
                else:
                    s.close()

            if self.askedtoquit:
                self.commandclass.reset('stop')
                time_uptime = int(time.time() - time.mktime(self.time_start))
                log.info('# STOPPING XiVO CTI Server %s (pid %d) / svn:%s # uptime %d s (since %s)'
                         % (self.xivoversion, os.getpid(), self.revision,
                            time_uptime, time.asctime(self.time_start)))
                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                    print '--- (stop) killing thread <%s>' % t.getName()
                    t._Thread__stop()
                daemonize.unlock_pidfile(PIDFILE)
                sys.exit(5)
            else:
                self.commandclass.reset('reload')
                self.askedtoquit = True
                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                    print '--- (reload) the thread <%s> remains' % t.getName()
                    # t._Thread__stop() # does not work in reload case (vs. stop case)
                return
        # }
        try:    # {
            # connexions ready for sending(writing)
            for sel_o in sels_o:
                try:
                    sel_o.process_sending()
                except ClientConnection.CloseException, cexc:
                    if sel_o in self.userinfo_by_requester:
                        userinfo = self.userinfo_by_requester.get(sel_o)
                        self.commandclass.manage_logout(userinfo, 'end_sending')
                        del self.userinfo_by_requester[sel_o]

                    log.info('TCP socket %s closed(sending %s) on %s'
                             % (self.fdlist_established[sel_o], cexc, sel_o.getpeername()))

                    if sel_o in self.fdlist_established:
                        del self.fdlist_established[sel_o]

                    self.commandclass.disconnected(sel_o)

            if sels_e:
                log.warning('got some sels_e %s' % sels_e)

            if sels_i:  # {
                for sel_i in sels_i: # {
                    # these AMI connections are used in order to manage AMI commands and events
                    if sel_i in self.amilist.fdlist():
                        try:
                            astid = self.amilist.astid(sel_i)
                            sock = self.amilist.ami[astid].sock
                            buf = sock.recv(200000)
                            if len(buf) == 0:
                                log.warning('%s AMI : CLOSING' % astid)
                                self.amilist.remove(astid)
                                sel_i.close()
                            else:
                                if astid is not None:
                                    try:
                                        manage_connection.handle_ami_event(self, astid, buf)
                                    except Exception:
                                        log.exception('(handle_ami_event) %s' % astid)
                        except Exception:
                            log.exception('(amilist)')

                    # other 'outgoing' connections
                    elif sel_i == self.outsock: # {
                        try:
                            msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                        except Exception:
                            log.exception('outsock')
                            msg = ''

                        if len(msg) == 0:
                            sel_i.close()
                            self.outsock = None
                            log.warning('WARNING - outsock has closed the connection')
                        else:
                            self.commandclass.handle_outsock(self.asterisklist[0], msg)

                    # } the UDP messages (ANNOUNCE) are catched here
                    elif sel_i in self.fdlist_udp_cti: # {
                        [kind, nmax] = self.fdlist_udp_cti[sel_i].split(':')
                        if kind == 'ANNOUNCE':
                            [data, sockparams] = sel_i.recvfrom(32768)
                            if sockparams[0] in self.ip_reverse_sht:
                                astid = self.ip_reverse_sht.get(sockparams[0])
                            else:
                                astid = 'xivo'
                            log.info('UDP %s <%s> %s => %s' % (kind, data.strip(), sockparams, astid))
                            if astid in self.configs:
                                # scheduling astid's AMI reconnection
                                k = threading.Timer(2, manage_connection.callback_timer_main,
                                                    (self, ('ipbxup', astid)))
                                k.start()
                        else:
                            log.warning('unknown kind %s received' % kind)

                    # } the new TCP connections (CTI, WEBI, (F)AGI, INFO) are catched here
                    elif sel_i in self.fdlist_listen_cti: # {
                        [kind, nmax] = self.fdlist_listen_cti[sel_i].split(':')
                        [connc, sockparams] = sel_i.accept()
                        if kind == 'FAGI':
                            if sockparams[0] in self.ip_reverse_sht:
                                astid = self.ip_reverse_sht.get(sockparams[0])
                            else:
                                astid = 'xivo'
                            log.info('TCP socket FAGI opened on %s:%d => %s'
                                     % (sockparams[0], sockparams[1], astid))
                            mfr = connc.makefile('rb', -1)
                            mfw = connc.makefile('wb', 0)
                            try:
                                fagi = fastagi.FastAGI(mfr, mfw)
                                self.commandclass.handle_fagi(astid, fagi)
                            except Exception:
                                log.exception('(fastagi) %s' % astid)
                            mfr.close()
                            mfw.close()
                            connc.close()
                            log.info('TCP socket FAGI closed on %s:%d' % (sockparams[0], sockparams[1]))
                        else:
                            log.info('TCP socket %s opened on %s:%d' % (kind,
                                                                        sockparams[0], sockparams[1]))
                            if kind == 'CTI':
                                connc = ClientConnection(connc, sockparams, self.commandclass.ctiseparator)
                                self.commandclass.connected(connc)
                            # appending the opened socket to the ones watched
                            # connc.setblocking(0)
                            # connc.settimeout(2)
                            if kind == 'INFO':
                                self.fdlist_established[connc] = interface_info.cliConn(connc, '\n')
                            else:
                                self.fdlist_established[connc] = kind

                    # } incoming TCP connections (CTI, WEBI, AGI, INFO)
                    elif sel_i in self.fdlist_established: # {
                        try: # {
                            kind = self.fdlist_established[sel_i]
                            requester = '%s:%d' % sel_i.getpeername()
                            if isinstance(sel_i, ClientConnection):
                                try:
                                    lines = sel_i.readlines()
                                    for line in lines:
                                        if line:
                                            manage_connection.manage_tcp_connections(self, sel_i, line, kind)
                                except ClientConnection.CloseException, cexc:
                                    if kind == 'CTI':
                                        if sel_i in self.userinfo_by_requester:
                                            userinfo = self.userinfo_by_requester.get(sel_i)
                                            self.commandclass.manage_logout(userinfo, 'end_receiving')
                                            del self.userinfo_by_requester[sel_i]
                                    if sel_i in self.fdlist_established:
                                        del self.fdlist_established[sel_i]
                                    if requester in self.commandclass.transfers_ref:
                                        self.commandclass.transfer_endbuf(requester)
                                    log.info('TCP socket %s closed(A %s) on %s' % (kind, cexc, requester))
                                    if kind == 'CTI':
                                        self.commandclass.disconnected(sel_i)
                            else: # {
                                closemenow = False

                                try:
                                    msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                    lmsg = len(msg)
                                except Exception:
                                    log.exception('connection to %s (%s)' % (requester, kind))
                                    lmsg = 0

                                if lmsg > 0:
                                    try:
                                        closemenow = manage_connection.manage_tcp_connections(self, sel_i, msg, kind)
                                    except Exception:
                                        log.exception('handling %s (%s)' % (requester, kind))

                                else:
                                    if kind == 'CTI':
                                        if sel_i in self.userinfo_by_requester:
                                            userinfo = self.userinfo_by_requester.get(sel_i)
                                            self.commandclass.manage_logout(userinfo, 'end_receiving')
                                            del self.userinfo_by_requester[sel_i]

                                doclose = False
                                if kind == 'WEBI':
                                    doclose = closemenow
                                elif kind == 'AGI':
                                    doclose = True
                                # CTI, 'INFO' : False

                                if lmsg == 0:
                                    doclose = True

                                if doclose:
                                    sel_i.close()
                                    if sel_i in self.fdlist_established:
                                        del self.fdlist_established[sel_i]
                                    if requester in self.commandclass.transfers_ref:
                                        self.commandclass.transfer_endbuf(requester)
                                    log.info('TCP socket %s closed(B) on %s' % (kind, requester))
                                    if kind == 'CTI':
                                        self.commandclass.disconnected(sel_i)
                            # }
                        # }
                        except Exception:
                            # socket.error : exc.args[0]
                            log.exception('[%s] %s' % (kind, sel_i))
                            try:
                                del self.fdlist_established[sel_i]
                                sel_i.close()
                                if sel_i in self.userinfo_by_requester:
                                    userinfo = self.userinfo_by_requester.get(sel_i)
                                    log.warning('logging off %s following unexpected socket breakup' % userinfo)
                                    self.commandclass.manage_logout(userinfo, 'exc')
                                    del self.userinfo_by_requester[sel_i]
                                else:
                                    log.warning('could not find a match for socket %s' % sel_i)
                            except Exception:
                                log.exception('[%s] (2nd exception)' % kind)

                    # }
                    # local pipe fd
                    elif self.pipe_queued_threads_commandclass[0] == sel_i: # {
                        try:
                            pipebuf = os.read(sel_i, 1024)
                            if len(pipebuf) == 0:
                                log.warning('pipe_queued_threads_commandclass has been closed')
                            else:
                                actionqueue = self.commandclass.checkqueue(pipebuf)
                                for actionname, actionarg in actionqueue.iteritems():
                                    if actionname == 'disconnlist-tcp':
                                        # disconnect when timeout after first connection
                                        disconnlist = actionarg
                                        if disconnlist:
                                            log.warning('checkqueue return : should disconnect %d connections'
                                                        % len(disconnlist))
                                            for connid in disconnlist:
                                                try:
                                                    self.commandclass.telldisconn(connid)
                                                except Exception:
                                                    log.exception('disconnlist-tcp')

                                                log.info('TCP socket %s closed(disconnlist) on %s'
                                                         % (self.fdlist_established[connid],
                                                            '%s:%d' % connid.getpeername()))
                                                del self.fdlist_established[connid]
                                                connid.close()
                        except Exception:
                            log.exception('[pipe_queued_threads_commandclass]')

                    # }
                    elif self.pipe_queued_threads_main[0] == sel_i: # {
                        try:
                            pipebuf = os.read(sel_i, 1024)
                            if len(pipebuf) == 0:
                                log.warning('pipe_queued_threads_main has been closed')
                            else:
                                manage_connection.checkqueue_main(self, pipebuf)
                        except Exception:
                            log.exception('[pipe_queued_threads_main]')

                    # }
                    try:
                        userdiscolist = self.commandclass.disconnlist
                        if userdiscolist:
                            log.warning('commandclass.disconnlist : should disconnect %d users' % len(userdiscolist))
                            for userinfo in userdiscolist:
                                log.warning('checkqueue return : will disconnect %s' % userinfo)
                                if 'login' in userinfo and 'connection' in userinfo.get('login'):
                                    connid = userinfo.get('login')['connection']
                                    if connid in self.fdlist_established:
                                        del self.fdlist_established[connid]
                                    else:
                                        log.warning('connid %s no more in fdlists' % connid)

                                    self.commandclass.manage_logout(userinfo, 'pipe')
                                    del self.userinfo_by_requester[connid]

                                    if not connid.isClosed:
                                        connid.close()
                                else:
                                    log.warning('WARNING - no login/connection field present in userinfo')
                        self.commandclass.clear_disconnlist()
                    except Exception:
                        log.exception('userdiscolist')

                    for astid in self.configs: # {
                        if (time.time() - self.lastrequest_time[astid]) > self.updates_period or self.update_userlist[astid]:
                            self.lastrequest_time[astid] = time.time()
                            log.info('[%s] %s : updates (computed timeout) %s (%s)'
                                     % (self.xdname, astid, time.asctime(), self.update_userlist[astid]))
                            try:
                                if self.outsock is None:
                                    self.outsock = self.commandclass.extrasock(self.extraconn)
                                manage_connection.update_amisocks(astid, self)
                                self.update_readconf()
                                self.commandclass.regular_update()
                            except Exception:
                                log.exception('%s : failed while updating lists and sockets (computed timeout)' % astid)
                            try:
                                if self.update_userlist[astid]:
                                    while self.update_userlist[astid]:
                                        listtorequest = self.update_userlist[astid].pop()
                                        self.commandclass.updates(astid, listtorequest)
                                else:
                                    self.commandclass.updates(astid, 'others') # signal-less updates ...
                            except Exception:
                                log.exception('%s : commandclass.updates() (computed timeout)' % astid)
                    # }
                # }
            # }
            else: # { when nothing happens on the sockets, we fall here sooner or later
                log.info('[%s] updates (select timeout) %s'
                          % (self.xdname, time.asctime()))
                for astid in self.configs:
                    try:
                        self.commandclass.updates(astid, 'others') # signal-less updates ...
                    except Exception:
                        log.exception('%s : commandclass.updates() (select timeout)' % astid)

                    self.lastrequest_time[astid] = time.time()

                    try:
                        if self.outsock is None:
                            self.outsock = self.commandclass.extrasock(self.extraconn)
                        manage_connection.update_amisocks(astid, self)
                        self.update_readconf()
                        self.commandclass.regular_update()
                    except Exception:
                        log.exception('%s : failed while updating lists and sockets (select timeout)' % astid)
                # }
            # }
        # }
        except Exception:
            log.exception('select step')
    # }

parse_command_line()
main = xivo_daemon()
