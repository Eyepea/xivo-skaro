#!/usr/bin/python
# vim: set fileencoding=utf-8 :

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Alternatively, XiVO CTI Server is available under other licenses directly
# contracted with Pro-formatique SARL. See the LICENSE file at top of the
# source tree or delivered in the installable package in which XiVO CTI Server
# is distributed for more details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


__version__   = '$Revision$'
__date__      = '$Date$'
__copyright__ = 'Copyright (C) 2007-2011 Proformatique'
__author__    = 'Corentin Le Gall'

"""
# 1) General description of XiVO CTI Server
# The XiVO CTI Server is a general-purpose daemon, whose basic features are :
#  - the monitoring of one or more Asterisk, through AMI
#  - taking care of Asteriks AGI requests
#  - the ability to receive incoming "CTI clients" connections
#  - the ability to relay commands (between a Web interface and Asterisk)
#  - the connection to one or more databases (cdr, directory, ...)
#  - the connection to a given server
# 
# 2) Primary data structures
# 
#  - users list
#  - contexts/companies list
# 
#  - asterisk / configurations
#  - phonelist
#
# 3) Main loop
# The main loop is triggered by a select() on the file descriptors for :
# - the AMI Event sockets (AMIsocks)
# - the incoming TCP sockets (CTI, WEBI, INFO, FAGI)
#
# 4) Custom-defined Plugins
#
"""

# debian.org modules
import getopt
from optparse import OptionParser
import os
import pickle
import select
import signal
import ssl
import socket
import string
import sys
import threading
import time
import logging
from logging.handlers import RotatingFileHandler
import Queue
import urllib2
import cjson

# XIVO CTI modules
from xivo_ctiservers.client_connection import ClientConnection
from xivo import daemonize
from xivo_ctiservers import cti_config

from xivo_ctiservers import interface_webi
from xivo_ctiservers import interface_info
from xivo_ctiservers import interface_cti
from xivo_ctiservers import interface_ami
from xivo_ctiservers import interface_fagi
from xivo_ctiservers import innerdata
from xivo_ctiservers import amiinterpret
from xivo_ctiservers import queue_logger

__alphanums__ = string.uppercase + string.lowercase + string.digits

LOGDAEMONNAME = 'ctid'
try:
    DAEMONNAME = os.path.basename(sys.argv[0])
except:
    DAEMONNAME = 'ctid'

# XIVO lib-python modules initialization
XIVO_CONF_FILE_DEFAULT = 'file:///etc/pf-xivo/ctiservers/ctiserver_default_configuration.json'
XIVO_CONF_FILE         = 'https://localhost/service/ipbx/json.php/private/ctiserver/configuration'
PIDFILE            = '/var/run/%s.pid' % DAEMONNAME
LOGFILENAME        = '/var/log/pf-xivo-cti-server/daemon.log'
GETOPT_SHORTOPTS   = 'dc:p:l:'
GETOPT_LONGOPTS    = ['debug', 'config=', 'pidfile=', 'logfile=']
debug_mode = False

BUFSIZE_LARGE = 8192
BUFSIZE_ANY = 512

filecert = '/usr/share/doc/libssl-dev/demos/sign/cert.pem'
filekey = '/usr/share/doc/libssl-dev/demos/sign/key.pem'
sslproto = ssl.PROTOCOL_TLSv1

def parse_command_line():
    global XIVO_CONF_FILE, PIDFILE, LOGFILENAME, debug_mode
    for opt, arg in getopt.getopt( sys.argv[1:], GETOPT_SHORTOPTS, GETOPT_LONGOPTS)[0]:
        if opt == '-c':
            XIVO_CONF_FILE = arg
        elif opt == '-d':
            debug_mode = True
        elif opt == '-p':
            PIDFILE = arg
        elif opt == '-l':
            LOGFILENAME = arg

class manage_connection:
    ## \brief Deals with requests from the UI clients.
    # \param connid connection identifier
    # \param msg message to process
    # \param sep separator to split the message
    # \return none

    @staticmethod
    def manage_tcp_connections(sel_i, msg, kind):
        """
        Dispatches the message's handling according to the connection's kind.
        """
        closemenow = False
        if not isinstance(kind, str): # CTI, INFO, WEBI
            f = kind.manage_connection(msg)
            try:
                if f:
                    if f.has_key('closemenow'):
                        closemenow = f.get('closemenow')
                    if f.has_key('message'):
                        kind.reply(f.get('message'))
                    elif f.has_key('warning'):
                        kind.reply(f.get('warning'))
            except Exception:
                log.exception('reply %s to %s' % (f, msg))
            # issue : when to define the recipient list ?
            # change status
            # find changes
            # warn
        else:
            log.warning('unknown connection kind %s' % kind)
        return closemenow



class xivo_daemon:
    xivoversion = '1.2'
    revision = __version__.split()[1]
    xdname = 'XiVO CTI Server'

    def __init__(self):
        # print sys.getdefaultencoding()
        logging.basicConfig(level = logging.INFO)
        #logging.basicConfig(level = logging.DEBUG)

        global log

        log = logging.getLogger('main')

        try:
            logfilehandler = RotatingFileHandler(LOGFILENAME)
            formatter = logging.Formatter('%%(asctime)s %s[%%(process)d] (%%(levelname)s) (%%(name)s): %%(message)s'
                                          % LOGDAEMONNAME)
            logfilehandler.setFormatter(formatter)
            logging.getLogger('').addHandler(logfilehandler)

        except Exception:
            log.exception('logfilehandler')

        if not debug_mode:
            daemonize.daemonize()

        daemonize.lock_pidfile_or_die(PIDFILE)

        signal.signal(signal.SIGINT, self.sighandler)
        signal.signal(signal.SIGTERM, self.sighandler)
        signal.signal(signal.SIGHUP, self.sighandler_reload)

        self.nreload = 0
        self.myami = {}
        self.safe = {}
        self.timeout_queue = Queue.Queue()
        self.pipe_queued_threads = None

        while True:
            try:
                self.main_loop()
            except Exception:
                # this will occur at server startup, when WEBI is not started yet
                # XXX this is a very naughty way, however, to handle that
                log.exception('main loop has crashed ... retrying in 5 seconds ...')
                time.sleep(5)

    ## \brief Handler for catching signals (in the main thread)
    # \param signum signal number
    # \param frame frame
    # \return none
    def sighandler(self, signum, frame):
        log.warning('(sighandler) signal %s lineno %s (atq = %s) received : quits' % (signum, frame.f_lineno, self.askedtoquit))
        for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
            print '--- living thread <%s>' % (t.getName())
            t._Thread__stop()
        self.askedtoquit = True
        return

    ## \brief Handler for catching signals (in the main thread)
    # \param signum signal number
    # \param frame frame
    # \return none
    def sighandler_reload(self, signum, frame):
        log.warning('(sighandler_reload) signal %s lineno %s (atq = %s) received : reloads' % (signum, frame.f_lineno, self.askedtoquit))
        self.askedtoquit = False
        return

    def find_matching_ipbxid(self, ipaddress):
        found_ipbxid = None
        for ipbxid, ipbxconfig in self.cconf.xc_json.get('ipbxes').iteritems():
            connparams = ipbxconfig.get('connection')
            cfg_ip_address = connparams.get('ipaddress')
            if ipaddress == socket.gethostbyname(cfg_ip_address):
                found_ipbxid = ipbxid
                break
        return found_ipbxid

    def checkqueue(self):
        log.info('entering checkqueue')
        ncount = 0
        while self.timeout_queue.qsize() > 0:
            ncount += 1
            (toload,) = self.timeout_queue.get()
            action = toload.get('action')
            if action == 'ipbxup':
                sockparams = toload.get('properties').get('sockparams')
                got_ip_address = sockparams[0]
                ipbxid = self.find_matching_ipbxid(got_ip_address)
                if ipbxid:
                    log.info('attempting to reconnect the AMI for %s' % ipbxid)
                    z = self.myami[ipbxid].connect()
                    self.fdlist_ami[z] = self.myami[ipbxid]
                else:
                    log.warning('did not found a matching ipbxid for the address %s'
                                % got_ip_address)
            elif action == 'ctilogin':
                connc = toload.get('properties')
                connc.close()
                if connc in self.fdlist_established:
                    del self.fdlist_established[connc]
                else:
                    log.warning('could not remove connexion : already done ...')
        return ncount

    def cb_timer(self, *args):
        try:
            tname = threading.currentThread()
            tname.setName('Thread-main')
            log.info('cb_timer (timer finished at %s) %s' % (time.asctime(), args))
            self.timeout_queue.put(args)
            os.write(self.pipe_queued_threads[1], 'main:\n')
        except Exception:
            log.exception('cb_timer %s' % args)
        return

    def main_loop(self):    # {
        self.askedtoquit = False

        self.time_start = time.localtime()
        log.info('# STARTING XiVO CTI Server %s (pid %d) / svn:%s # (0/3) Starting (%d)'
                 % (self.xivoversion, os.getpid(), self.revision, self.nreload))
        self.nreload += 1

        # global default definitions
        incoming_tcp_ports = []
        incoming_udp_ports = []
        ctilog = None

        self.update_userlist = {}
        self.lastrequest_time = {}

        self.cconf = cti_config.Config(XIVO_CONF_FILE, XIVO_CONF_FILE_DEFAULT)

        queue_logger.queue_logger.init(self.cconf.xc_json['main'].get('asterisk_queuestat_db'))

        xivoconf_general = self.cconf.xc_json['main']

        # loads the general configuration
        self.updates_period = int(xivoconf_general.get('updates_period', '60'))
        ctilog = xivoconf_general.get('ctilog_db_uri')
        socktimeout = xivoconf_general.get('sockettimeout', '2')
        prefixfile = xivoconf_general.get('prefixfile')
        parting_ipbxid_context = xivoconf_general.get('parting_ipbxid_context')

        socket.setdefaulttimeout(float(socktimeout))

        if not self.pipe_queued_threads:
            self.pipe_queued_threads = os.pipe()

        for ipbxid, ipbxconfig in self.cconf.xc_json.get('ipbxes').iteritems():
            # interface : safe deposit
            self.safe[ipbxid] = innerdata.Safe(self, ipbxid, ipbxconfig.get('urllists'))
            # interface : AMI
            self.myami[ipbxid] = interface_ami.AMI(self, ipbxid, ipbxconfig.get('connection'))
            self.commandclass = amiinterpret.AMI_1_8(self, ipbxid)

            log.info('# STARTING %s / svn:%s / %d'
                     % (self.xdname, self.safe[ipbxid].version(), self.nreload))

            self.safe[ipbxid].set_ctilog(ctilog)
            self.safe[ipbxid].read_internatprefixes(prefixfile)
            self.safe[ipbxid].set_partings(parting_ipbxid_context)

        # sockets management
        self.fdlist_established = {}
        self.fdlist_listen_cti = {}
        self.fdlist_udp_cti = {}
        self.fdlist_ami = {}

        log.info("the monitored ipbx's is/are : %s" % self.cconf.xc_json.get('ipbxes').keys())
        log.info('# STARTING %s # (1/2) AMI socket connections + fetch Web Services' % self.xdname)

        for ipbxid in self.cconf.xc_json.get('ipbxes').keys():
            try:
                self.update_userlist[ipbxid] = []
                self.lastrequest_time[ipbxid] = time.time()
                z = self.myami[ipbxid].connect()
                self.fdlist_ami[z] = self.myami[ipbxid]
            except Exception:
                log.exception('%s : failed while connecting to the ipbx' % ipbxid)

            try:
                self.safe[ipbxid].update_config_list_all()
            except Exception:
                log.exception('%s : commandclass.updates()' % ipbxid)
        # }

        log.info('# STARTING %s # (2/2) listening sockets (CTI, WEBI, FAGI, INFO)' % self.xdname)
        # opens the listening socket for incoming (CTI, WEBI, FAGI, INFO) connections
        for kind, bind_and_port in xivoconf_general.get('incoming_tcp_ports').iteritems():
            try:
                (bind, port) = bind_and_port
                gai = socket.getaddrinfo(bind, port, 0, socket.SOCK_STREAM, socket.SOL_TCP)
                if not gai:
                    continue
                (afinet, socktype, proto, dummy, bindtuple) = gai[0]
                UIsock = socket.socket(afinet, socktype)
                UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                UIsock.bind(bindtuple)
                UIsock.listen(10)
                self.fdlist_listen_cti[UIsock] = '%s:%s' % (kind, 1)
            except Exception:
                log.exception('%s' % bind_and_port)

        for kind, bind_and_port in xivoconf_general.get('incoming_udp_ports').iteritems():
            try:
                (bind, port) = bind_and_port
                gai = socket.getaddrinfo(bind, port, 0, socket.SOCK_DGRAM, socket.SOL_UDP)
                if not gai:
                    continue
                (afinet, socktype, proto, dummy, bindtuple) = gai[0]
                UIsock = socket.socket(afinet, socktype)
                UIsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                UIsock.bind(bindtuple)
                self.fdlist_udp_cti[UIsock] = '%s:%s' % (kind, 1)
            except Exception:
                log.exception('%s' % bind_and_port)

        # Main select() loop - Receive messages
        while not self.askedtoquit:
            self.select_step()
    # }

    def loop_over_cti_queue(self, ipbxid):
        cti_queue = self.safe[ipbxid].events_cti
        while cti_queue.qsize() > 0:
            it = cti_queue.get()
            for k in self.fdlist_established.itervalues():
                if not isinstance(k, str) and k.kind == 'CTI':
                    k.reply(it)
        return

    def select_step(self):  # {
        try:    # {
            fdtodel = []
            for cn in self.fdlist_established.keys():
                if isinstance(cn, ClientConnection):
                    if cn.isClosed and cn not in fdtodel:
                        fdtodel.append(cn)
                    if cn.toClose and not cn.need_sending():
                        cn.close()
                        if cn not in fdtodel:
                            fdtodel.append(cn)
            if fdtodel:
                log.warning('there are fd to delete : %s' % fdtodel)
                for cn in fdtodel:
                    del self.fdlist_established[cn]

            self.fdlist_full = list()
            self.fdlist_full.append(self.pipe_queued_threads[0])
            # put AMI fd's before FAGI ones in order to be properly synced
            self.fdlist_full.extend(self.fdlist_ami.keys())
            self.fdlist_full.extend(self.fdlist_listen_cti.keys())
            self.fdlist_full.extend(self.fdlist_udp_cti.keys())
            self.fdlist_full.extend(self.fdlist_established.keys())
            writefds = []
            for iconn, kind in self.fdlist_established.iteritems():
                if kind == 'CTI' and iconn.need_sending():
                    writefds.append(iconn)
            [sels_i, sels_o, sels_e] = select.select(self.fdlist_full, writefds, [],
                                                     self.updates_period)
        # }
        except Exception:  # {
            log.exception('(select) probably Ctrl-C or daemon stop or daemon restart ...')
            log.warning('(select) self.askedtoquit=%s fdlist_full=%s'
                        % (self.askedtoquit, self.fdlist_full))
            log.warning('(select) current open TCP connections : (CTI, WEBI, FAGI, INFO) %s'
                        % self.fdlist_established)
            log.warning('(select) current open TCP connections : (AMI) %s'
                        % self.fdlist_ami.keys())

            for s in self.fdlist_full:
                if s in self.fdlist_established:
                    if self.askedtoquit:
                        self.fdlist_established[s].disconnected('stop')
                    else:
                        self.fdlist_established[s].disconnected('reload')
                if not isinstance(s, int):
                    # the only one 'int' is the (read) pipe : no need to close/reopen it
                    s.close()

            if self.askedtoquit:
                # self.commandclass.reset('stop') # used to call __fill_ctilog__('daemon stop', mode)
                time_uptime = int(time.time() - time.mktime(self.time_start))
                log.info('# STOPPING XiVO CTI Server %s (pid %d) / svn:%s # uptime %d s (since %s)'
                         % (self.xivoversion, os.getpid(), self.revision,
                            time_uptime, time.asctime(self.time_start)))
                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                    print '--- (stop) killing thread <%s>' % t.getName()
                    t._Thread__stop()
                daemonize.unlock_pidfile(PIDFILE)
                sys.exit(5)
            else:
                # self.commandclass.reset('reload')
                self.askedtoquit = True
                for t in filter(lambda x: x.getName() != 'MainThread', threading.enumerate()):
                    print '--- (reload) the thread <%s> remains' % t.getName()
                    # t._Thread__stop() # does not work in reload case (vs. stop case)
                return
        # }
        try:    # {
            # connexions ready for sending(writing)
            for sel_o in sels_o:
                try:
                    sel_o.process_sending()
                except ClientConnection.CloseException, cexc:
                    if sel_o in self.fdlist_established:
                        kind = self.fdlist_established[sel_o]
                        log.info('TCP socket %s closed(sending %s) on %s'
                                 % (kind, cexc, sel_o.getpeername()))
                        kind.disconnected('end_sending')
                        sel_o.close()
                        del self.fdlist_established[sel_o]

            if sels_e:
                log.warning('got some sels_e %s' % sels_e)

            if sels_i:  # {
                for sel_i in sels_i: # {
                    # these AMI connections are used in order to manage AMI commands and events
                    if sel_i in self.fdlist_ami.keys():
                        try:
                            amiint = self.fdlist_ami[sel_i]
                            ipbxid = amiint.ipbxid
                            buf = sel_i.recv(200000)
                            if len(buf) == 0:
                                log.warning('%s AMI : CLOSING' % ipbxid)
                                del self.fdlist_ami[sel_i]
                                sel_i.close()
                            else:
                                try:
                                    self.fdlist_ami[sel_i].handle_ami_event(buf)
                                    self.loop_over_cti_queue(ipbxid)
                                except Exception:
                                    log.exception('(handle_ami_event) %s' % ipbxid)
                        except Exception:
                            log.exception('(amilist)')

                    # } the UDP messages (ANNOUNCE) are catched here
                    elif sel_i in self.fdlist_udp_cti: # {
                        [kind, nmax] = self.fdlist_udp_cti[sel_i].split(':')
                        if kind == 'ANNOUNCE':
                            [data, sockparams] = sel_i.recvfrom(32768)
                            log.info('UDP %s <%s> %s' % (kind, data.strip(), sockparams))
                            # scheduling AMI reconnection
                            k = threading.Timer(1, self.cb_timer,
                                                ({'action' : 'ipbxup',
                                                  'properties' : { 'data' : data,
                                                                   'sockparams' : sockparams }},))
                            k.setName('Thread-ipbxup-%s' % data.strip())
                            k.start()
                        else:
                            log.warning('unknown kind %s received' % kind)

                    # } the new TCP connections (CTI, WEBI, FAGI, INFO) are catched here
                    elif sel_i in self.fdlist_listen_cti: # {
                        [kind, nmax] = self.fdlist_listen_cti[sel_i].split(':')
                        [connc, sockparams] = sel_i.accept()
                        ctiseparator = '\n'
                        log.info('TCP socket %s opened on %s:%d' % (kind,
                                                                    sockparams[0], sockparams[1]))

                        if kind == 'CTI':
                            connc = ClientConnection(connc, sockparams, ctiseparator)
                        elif kind == 'CTIS':
                            try:
                                connstream = ssl.wrap_socket(connc,
                                                             server_side = True,
                                                             certfile = filecert,
                                                             keyfile = filekey,
                                                             ssl_version = sslproto)
                                connc = ClientConnection(connstream, sockparams, ctiseparator)
                            except ssl.SSLError, exc:
                                log.exception('%s:%s:%d' % (kind, sockparams[0], sockparams[1]))
                                connc.close()
                                connc = None
                        # appending the opened socket to the ones watched
                        # connc.setblocking(0)
                        # connc.settimeout(2)
                        if connc:
                            if kind == 'INFO':
                                nc = interface_info.INFO(self)
                            elif kind == 'WEBI':
                                nc = interface_webi.WEBI(self)
                            elif kind in ['CTI', 'CTIS']:
                                nc = getattr(interface_cti, kind)(self)
                            elif kind == 'FAGI':
                                nc = interface_fagi.FAGI(self)

                            nc.connected(connc)
                            if kind in ['WEBI', 'FAGI', 'INFO']:
                                ipbxid = self.find_matching_ipbxid(sockparams[0])
                                nc.set_ipbxid(ipbxid)

                            if kind in ['CTI', 'CTIS']:
                                nc.logintimer = threading.Timer(int(self.cconf.xc_json['main'].get('logintimeout', 5)),
                                                                self.cb_timer,
                                                                ({'action' : 'ctilogin',
                                                                  'properties' : connc},))
                                nc.logintimer.start()
                            self.fdlist_established[connc] = nc
                        else:
                            log.warning('connc is not defined ...')

                    # } incoming TCP connections (CTI, WEBI, AGI, INFO)
                    elif sel_i in self.fdlist_established: # {
                        try: # {
                            kind = self.fdlist_established[sel_i]
                            requester = '%s:%d' % sel_i.getpeername()[:2]
                            if isinstance(sel_i, ClientConnection):
                                try:
                                    lines = sel_i.readlines()
                                    for line in lines:
                                        if line:
                                            manage_connection.manage_tcp_connections(sel_i, line, kind)
                                            for ipbxid in self.safe.keys():
                                                self.loop_over_cti_queue(ipbxid)
                                except ClientConnection.CloseException, cexc:
                                    kind.disconnected('end_receiving')
                                    del self.fdlist_established[sel_i]
                                    # if requester in self.commandclass.transfers_ref:
                                    #   self.commandclass.transfer_endbuf(requester)
                                    log.info('TCP socket %s closed(A %s) on %s' % (kind.kind, cexc, requester))
                            else: # {
                                closemenow = False

                                try:
                                    msg = sel_i.recv(BUFSIZE_LARGE, socket.MSG_DONTWAIT)
                                    lmsg = len(msg)
                                except Exception:
                                    log.exception('connection to %s (%s)' % (requester, kind))
                                    lmsg = 0

                                if lmsg > 0:
                                    try:
                                        closemenow = manage_connection.manage_tcp_connections(sel_i, msg, kind)
                                        for ipbxid in self.safe.keys():
                                            self.loop_over_cti_queue(ipbxid)
                                    except Exception:
                                        log.exception('handling %s (%s)' % (requester, kind))
                                else:
                                    closemenow = True
                                    # XXX connc : kind.manage_logout('end_receiving')

                                if closemenow:
                                    kind.disconnected('by_client')
                                    sel_i.close()
                                    del self.fdlist_established[sel_i]
                                    # if requester in self.commandclass.transfers_ref:
                                    #   self.commandclass.transfer_endbuf(requester)
                                    log.info('TCP socket %s closed(B) on %s' % (kind.kind, requester))
                            # }
                        # }
                        except Exception:
                            # socket.error : exc.args[0]
                            log.exception('[%s] %s' % (kind, sel_i))
                            try:
                                log.warning('logging off %s following unexpected socket breakup' % userinfo)
                                kind.disconnected('exception')
                                sel_i.close()
                                del self.fdlist_established[sel_i]
                            except Exception:
                                log.exception('[%s] (2nd exception)' % kind)

                    # }
                    # local pipe fd
                    elif self.pipe_queued_threads[0] == sel_i: # {
                        try:
                            pipebuf = os.read(sel_i, 1024)
                            if len(pipebuf) == 0:
                                log.warning('pipe_queued_threads has been closed')
                            else:
                                for pb in pipebuf.split('\n'):
                                    if not pb:
                                        continue
                                    [kind, where] = pb.split(':')
                                    if kind == 'innerdata':
                                        nactions = self.safe[where].checkqueue()
                                        log.info('handled %d actions for %s' % (nactions, kind))
                                    elif kind == 'main':
                                        nactions = self.checkqueue()
                                        log.info('handled %d actions for %s' % (nactions, kind))
                                    elif kind == 'ami':
                                        nactions = self.myami[where].checkqueue()
                                        log.info('handled %d actions for %s' % (nactions, kind))
                                    else:
                                        log.warning('unknown kind %s' % kind)
                        except Exception:
                            log.exception('[pipe_queued_threads]')

                    # }
                    for ipbxid, safe in self.safe.iteritems():
                        if (time.time() - self.lastrequest_time[ipbxid]) > self.updates_period or self.update_userlist[ipbxid]:
                            self.lastrequest_time[ipbxid] = time.time()
                            log.info('[%s] %s : updates (computed timeout) %s (%s)'
                                     % (self.xdname, ipbxid, time.asctime(), self.update_userlist[ipbxid]))
                            try:
                                # manage_connection.update_amisocks(ipbxid, self)
                                self.cconf.update()
                                safe.regular_update()
                            except Exception:
                                log.exception('%s : failed while updating lists and sockets (computed timeout)'
                                              % ipbxid)
                            try:
                                if self.update_userlist[ipbxid]:
                                    while self.update_userlist[ipbxid]:
                                        tmp_ltr = self.update_userlist[ipbxid].pop()
                                        listtorequest = tmp_ltr[5:-12] + 's'
                                        safe.update_config_list(listtorequest)
                                else:
                                    safe.update_config_list_all()
                            except Exception:
                                log.exception('%s : commandclass.updates() (computed timeout)' % ipbxid)
                    # }
                # }
            # }
            else: # { when nothing happens on the sockets, we fall here sooner or later
                log.info('[%s] updates (select timeout) %s'
                          % (self.xdname, time.asctime()))
                for ipbxid, safe in self.safe.iteritems():
                    try:
                        safe.update_config_list_all()
                    except Exception:
                        log.exception('%s : commandclass.updates() (select timeout)' % ipbxid)

                    self.lastrequest_time[ipbxid] = time.time()

                    try:
                        # manage_connection.update_amisocks(ipbxid, self)
                        self.cconf.update()
                        safe.regular_update()
                    except Exception:
                        log.exception('%s : failed while updating lists and sockets (select timeout)' % ipbxid)
                # }
            # }
        # }
        except Exception:
            log.exception('select step')
    # }

parse_command_line()
main = xivo_daemon()
